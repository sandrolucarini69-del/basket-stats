<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Basket Stats ‚Äì File Unico</title>

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<style>
/* =========================
   BASE
========================= */
:root{ --vh: 100vh; }
@supports (height: 100dvh){ :root{ --vh: 100dvh; } }

*{ box-sizing:border-box; }
body{ margin:0; font-family:Arial, sans-serif; background:#f2f2f2; color:#111; }
html, body{ height:100%; }
body{ -webkit-text-size-adjust: 100%; }
@media (hover: none) and (pointer: coarse){ input, select, textarea{ font-size:16px !important; } }

button{ border:none; border-radius:4px; cursor:pointer; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
button:disabled{ opacity:.5; cursor:not-allowed; }

.green{background:#2ecc71;color:#fff;}
.red{background:#e74c3c;color:#fff;}
.gray{background:#7f8c8d;color:#fff;}
.blue{background:#3498db;color:#fff;}

/* =========================
   TOP BAR
========================= */
:root{
  --sideW: 300px;
  --clockH: 44px;
}

.topbar{
  background:#000; color:#fff;
  padding: calc(6px + env(safe-area-inset-top)) calc(10px + env(safe-area-inset-right)) 6px calc(10px + env(safe-area-inset-left));
  display:grid;
  grid-template-columns: var(--sideW) 1fr var(--sideW);
  align-items:start;
  gap:10px;
}

.side-spacer{ display:flex; align-items:flex-start; justify-content:flex-start; }
.left-pack{ display:block; }

.qcol-left{
  display:flex;
  flex-direction:column;
  gap:6px;
  padding-top:2px;
  align-items:flex-start;
}
.qrow{
  display:grid;
  grid-template-columns:28px 36px 36px;
  gap:10px;
  color:#f1c40f;
  font-size:12px;
  align-items:center;
}
.qrow strong{ color:#fff; }

.center{ text-align:center; }
#clock{
  font-size:34px;
  font-weight:bold;
  height: var(--clockH);
  line-height: var(--clockH);
}

.clock-controls{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:10px;
  margin-top:2px;
}
.clock-controls button{
  padding:4px 12px;
  font-size:14px;
}

.quarter-label{
  font-size:16px;
  font-weight:bold;
  margin-top:6px;
  cursor:pointer;
}

.score-row{
  display:flex;
  justify-content:center;
  align-items:flex-start;
  gap:12px;
  margin-top:6px;
  flex-wrap:wrap;
}
.team-box{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:4px;
  flex: 1 1 0;
  min-width:0;
}
.team-box input{
  background:#000; border:none; color:#fff;
  font-weight:bold; text-align:center;
  width:100%;
  font-size: clamp(14px, 3.4vw, 20px);
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
.team-fsq{
  font-size: clamp(12px, 3vw, 18px);
  color:#f1c40f; font-weight:bold;
  letter-spacing:1px; line-height:1.1;
}
.team-fouls-danger{ color:#e74c3c !important; font-weight:bold; }

.score-big{
  flex: 0 0 auto;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  white-space:nowrap;
  gap:8px;
  font-weight:bold;
  letter-spacing:0;
  font-size: clamp(26px, 7.6vw, 42px);
}

.undo{
  display:flex;
  flex-direction:column;
  align-items:flex-end;
  gap:6px;
  width:280px;
}
.undo-info{
  color:#f1c40f;
  max-width:280px;
  overflow:hidden;
  text-overflow:ellipsis;
  font-size:18px;
  line-height:1.2;
  text-align:right;
}

.right-controls{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  width:100%;
  height: var(--clockH);
  align-items:center;
  justify-content:flex-end;
  overflow:visible;
}
.right-controls button{
  height:32px;
  padding:0 8px;
  font-size:12px;
  font-weight:bold;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  line-height:32px;
  white-space:nowrap;
  flex:0 0 auto;
}

.data-toggle{
  width: fit-content;
  max-width: 100%;
  height:32px;
  padding: 0 14px;
  font-size:12px;
  font-weight:bold;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  white-space:nowrap;
  align-self: flex-end; /* segue l'allineamento della colonna undo (desktop) */
}

.match-data-panel{
  width:100%;
  background:#111;
  border:1px solid #333;
  border-radius:8px;
  padding:8px;
}
.match-data-grid{ display:grid; grid-template-columns:1fr; gap:8px; }
.match-data-panel .match-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  font-size:12px;
  color:#f1c40f;
  white-space:nowrap;
}
.match-data-panel .match-row label{
  color:#fff;
  font-weight:bold;
  flex:0 0 auto;
}
.match-data-panel .match-row input{
  flex:1 1 auto;
  width:auto;
  min-width: 120px;
  max-width: 220px;
  background:#000;
  border:1px solid #333;
  color:#fff;
  padding:3px 6px;
  border-radius:4px;
  font-size:12px;
}
@media (max-width: 520px){
  .match-data-panel .match-row{
    flex-direction:column;
    align-items:stretch;
    white-space:normal;
  }
  .match-data-panel .match-row input{ max-width:none; width:100%; }
}

/* =========================
   HEADER SQUADRE
========================= */
.section-header{
  background:#000;
  color:#fff;
  padding:6px 10px;
  display:flex;
  align-items:center;
  gap:14px;
  flex-wrap:wrap;
  position:relative;
}
.section-title{
  font-weight:bold;
  letter-spacing:.3px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  max-width:40%;
}
.section-controls{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
.section-controls .stat{
  display:flex;
  align-items:center;
  gap:6px;
  white-space:nowrap;
  font-weight:bold;
}
.furbo-push{ margin-left:auto; }

#minusBtn{ padding:4px 12px; font-weight:bold; }
#minusBtn.active{
  background:#e67e22; color:#fff;
  animation: furboPulse 1s infinite;
}
@keyframes furboPulse{
  0%   { box-shadow: 0 0 0 0 rgba(230,126,34,0.70); }
  70%  { box-shadow: 0 0 0 10px rgba(230,126,34,0); }
  100% { box-shadow: 0 0 0 0 rgba(230,126,34,0); }
}
.fts-danger{ color:#e74c3c; font-weight:bold; }

.clock-system-mid{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  gap:6px;
  align-items:center;
}
.clock-system-mid button{
  padding:2px 8px;
  font-size:11px;
  height:26px;
  border-radius:4px;
}

/* =========================
   TABELLE ‚Äì FIX ‚ÄúNON ESCE A DESTRA‚Äù
   - NO min-width
   - table-layout fixed
   - colgroup a percentuali (100%)
   - FS/RA/... tutte uguali (c-stat)
========================= */
.wrapper{ padding:8px; background:#fff; overflow:hidden; } /* niente scroll orizzontale */
table{
  border-collapse:collapse;
  width:100%;
  table-layout:fixed;
}
th, td{
  border:1px solid #ccc;
  padding:4px 2px;
  text-align:center;
  font-size:12px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
thead th{ background:#000; color:#fff; }

/* colgroup (100%):
   # 3% | Atleta 27% | PTS 3% | FF 3% | MIN 5%
   2PT 8% | 3PT 8% | TL 8%
   8 stat uguali: 35% / 8 = 4.375% ciascuna
*/
col.c-num   { width:3%; }
col.c-name  { width:23%; }
col.c-pts   { width:3%; }
col.c-ff    { width:3%; }
col.c-min   { width:5%; }
col.c-pm    { width:4%; }
col.c-shot  { width:8%; }
col.c-stat  { width:4.375%; }

/* Atleta cell: input + IN/OUT + ESP in una riga */
td.name{
  text-align:left;
  display:flex;
  align-items:center;
  gap:8px;
}
.player-name-input{
  flex:1 1 auto;
  min-width:0;
  border:none;
  border-bottom:1px solid #ddd;
  padding:2px 4px;
  font-weight:bold;
  background:transparent;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.player-name-input:focus{ outline:none; border-bottom:1px solid #3498db; }

.player-num-input{
  width:28px;
  border:none;
  border-bottom:1px solid #ddd;
  text-align:center;
  padding:2px 0;
  font-weight:bold;
  background:transparent;
}
.player-num-input:focus{ outline:none; border-bottom:1px solid #3498db; }
.player-num-input::-webkit-outer-spin-button,
.player-num-input::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
.player-num-input[type=number]{ -moz-appearance:textfield; }

.status-wrap{
  flex:0 0 auto;
  display:inline-flex;
  align-items:center;
  gap:8px;
  white-space:nowrap;
}
.status-wrap .io-btn{
  width:40px;
  padding:2px 0;
  font-size:11px;
}
.in { background:#27ae60 !important; color:#fff; }
.out{ background:#7f8c8d !important; color:#fff; }

.foul-out{
  background:#c0392b !important;
  color:#fff !important;
  cursor:not-allowed !important;
}

.esp-btn{
  background:#c0392b;
  color:#fff;
  font-weight:bold;
  padding:2px 6px;
  height:24px;
  font-size:11px;
  border-radius:6px;
  touch-action: manipulation;
  user-select:none;
}
.esp-btn:disabled{ opacity:.65; cursor:not-allowed; }
.esp-btn.holding{
  animation: espHoldPulse .55s infinite;
  outline: 2px solid rgba(0,0,0,0.25);
}
@keyframes espHoldPulse{
  0%   { transform: scale(1);   filter: brightness(1); }
  50%  { transform: scale(1.08); filter: brightness(1.15); }
  100% { transform: scale(1);   filter: brightness(1); }
}

/* celle ‚Äúshot‚Äù compatte */
.shot{ display:flex; justify-content:center; align-items:center; gap:4px; }
.shot span{ font-size:11px; }
.shot button{
  padding:2px 6px;
  font-size:11px;
}

/* bottoni nelle celle stat: non devono allargare */
td button.blue{
  width:100%;
  padding:2px 0;
  font-size:11px;
  min-width:0;
}

/* righe IN evidenziate */
.in-row td{ background:#ffe44d !important; border-color:#c9a800 !important; }
.in-row .player-name-input, .in-row .player-num-input{ background:transparent; }

.ff-warning { color:#f39c12; font-weight:bold; }
.ff-danger  { color:#e74c3c; font-weight:bold; }

.team-fouls-danger{ color:#e74c3c !important; font-weight:bold; }

/* =========================
   RESPONSIVE TOPBAR
========================= */
@media (max-width: 980px){
  .topbar{
    grid-template-columns: 1fr !important;
    grid-auto-rows: auto;
    row-gap: 10px;
    align-items: stretch;
  }
  .side-spacer{ justify-content:center; }
  .undo{ width:100% !important; align-items:center !important; }
  .undo-info{ max-width:100% !important; text-align:center !important; }
  .right-controls{ height:auto !important; flex-wrap:wrap !important; justify-content:center !important; }
  .data-toggle{ align-self:center; }
  .clock-system-mid{ position:static; transform:none; order: 99; margin-left:auto; }
}

/* =========================
   MICRO-RESPONSIVE TABELLA (senza scroll)
========================= */
@media (max-width: 520px){
  th, td{ font-size:10px; padding:3px 1px; }
  .shot span{ font-size:10px; }
  .shot button{ padding:1px 4px; font-size:10px; }
  td button.blue{ font-size:10px; padding:1px 0; }
  .player-num-input{ width:22px; }
  .status-wrap .io-btn{ width:34px; font-size:10px; }
  .esp-btn{ height:22px; font-size:10px; padding:2px 5px; }
}

/* =========================
   OVERLAY STATISTICHE
========================= */
#statsOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.82);
  display:none;
  z-index:9999;
}
#statsPanel{
  position:absolute;
  inset: calc(18px + env(safe-area-inset-top)) calc(18px + env(safe-area-inset-right)) calc(18px + env(safe-area-inset-bottom)) calc(18px + env(safe-area-inset-left));
  background:#fff;
  border-radius:12px;
  overflow:hidden;
  display:flex;
  flex-direction:column;
}
#statsHeader{
  background:#000;
  color:#fff;
  padding:10px 12px;
  display:flex;
  align-items:center;
  gap:10px;
}
#statsHeader .title{ font-weight:bold; letter-spacing:.3px; }
#statsHeader .spacer{ margin-left:auto; }
#statsHeader button{ padding:6px 10px; font-weight:bold; }

.stats-meta{
  display:flex;
  flex-direction:column;
  gap:2px;
  margin-left:12px;
  min-width:260px;
  max-width:760px;
}
.stats-meta-block{
  font-size:12px;
  color:#f1c40f;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  line-height:1.2;
}

.score-line{font-size:18px;font-weight:900;color:#fff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

.meta-splits{
  display:flex;
  gap:10px;
  align-items:baseline;
  font-variant-numeric:tabular-nums;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
.meta-splits .lbl{
  min-width:120px;
  color:#f1c40f;
  font-weight:900;
}
.meta-splits .vals{
  color:#f1c40f;
  font-weight:800;
}

/* zebra SOLO overlay stats + libreria JSON */
.stats-table tbody tr:nth-child(odd){ background:#fff; }
.stats-table tbody tr:nth-child(even){ background:#e0e0e0; }
.stats-table tfoot td{ background:#cfe8ff; font-weight:900; }

.lib-table tbody tr:nth-child(odd){ background:#fff; }
.lib-table tbody tr:nth-child(even){ background:#e0e0e0; }

#statsBody{ padding:10px; overflow:auto; }

.stats-block{ margin-bottom:14px; }
.stats-block h3{ margin:8px 0 6px; font-size:14px; }
.stats-table{
  width:100%;
  border-collapse:collapse;
  table-layout:auto;
  font-size:12px;
}
.stats-table th, .stats-table td{
  border:1px solid #ddd;
  padding:6px;
  text-align:center;
  white-space:nowrap;
}
.stats-table thead th{ background:#111; color:#fff; }
.stats-table td.name{ text-align:left; font-weight:bold; }
tfoot td{ background:#f6f6f6; font-weight:bold; }
.pir-col{ font-weight:bold; }
.pm-pos{ color:#2ecc71; font-weight:bold; }
.pm-neg{ color:#e74c3c; font-weight:bold; }

/* =========================
   OVERLAY LIBRERIA PARTITE
========================= */
#gamesOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.82);
  display:none;
  z-index:10000;
}
#gamesPanel{
  position:absolute;
  inset: calc(18px + env(safe-area-inset-top)) calc(18px + env(safe-area-inset-right)) calc(18px + env(safe-area-inset-bottom)) calc(18px + env(safe-area-inset-left));
  background:#fff;
  border-radius:12px;
  overflow:hidden;
  display:flex;
  flex-direction:column;
}
#gamesHeader{
  background:#000;
  color:#fff;
  padding:10px 12px;
  display:flex;
  align-items:center;
  gap:10px;
}
#gamesHeader .title{ font-weight:bold; letter-spacing:.3px; }
#gamesHeader .spacer{ margin-left:auto; }
#gamesHeader button{ padding:6px 10px; font-weight:bold; }
#gamesBody{ padding:10px; overflow:auto; }

.lib-actions{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  align-items:center;
  margin-bottom:10px;
}
#libInfo{
  margin-left:auto;
  font-weight:bold;
  color:#7f8c8d;
}
.lib-table{
  width:100%;
  border-collapse:collapse;
  table-layout:fixed;
  font-size:13px;
}
.lib-table th, .lib-table td{
  border:1px solid #ccc;
  padding:6px;
}
.lib-table thead th{
  background:#111;
  color:#fff;
}
.lib-ellipsis{
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* =========================
   BONUS FALLI (FTS>=4) ‚Äì opzionale su tabella
========================= */
.section-controls .mini-btn{
  height:22px;
  padding:0 8px;
  font-size:11px;
  font-weight:bold;
  border-radius:6px;
  line-height:22px;
}
.wrapper.bonus-active{
  outline:2px solid rgba(231,76,60,.75);
  outline-offset:-2px;
}
.wrapper.bonus-active thead th{
  background:#8e1b12;
}
.bonus-banner{
  display:none;
  background:#8e1b12;
  color:#fff;
  font-weight:bold;
  padding:6px 10px;
  font-size:12px;
  letter-spacing:.3px;
}


/* =========================
   PUNTI GLOBALI RAPIDI (+1/+2/+3) con toggle ¬±
========================= */
.score-quick{
  display:flex;
  flex-direction:column;
  gap:4px;
  align-items:center;
  justify-content:flex-start;
  min-width:0;
}
.score-quick .row{
  display:flex;
  gap:4px;
  flex-wrap:wrap;
}
.score-quick button{
  height:24px;
  padding:0 7px;
  font-size:11px;
  font-weight:bold;
  border-radius:6px;
  line-height:24px;
}



/* FIX: Dati partita sotto/accanto a Salva senza sovrapposizioni */
.right-controls{
  height:auto !important;
  flex-wrap:wrap !important;
  gap:6px !important;
}


/* =========================
   HEADER FISSO (SCROLL PAGINA)
========================= */
.topbar{
  position: sticky;
  top: 0;
  z-index: 1000;
}

body{
  scroll-padding-top: 120px; /* altezza media topbar */
}



/* =========================
   STICKY STACK (come screenshot)
   - Topbar: gi√† sticky
   - Header Squadra A: sticky sotto topbar
   - Intestazione tabella A: sticky mentre scorrono SOLO gli atleti (scroll nel wrapper A)
========================= */
:root{
  --topbarH: 120px;    /* fallback: viene aggiornato via JS */
  --sectionAH: 52px;   /* fallback: viene aggiornato via JS */
}

#sectionHeaderA{
  position: sticky;
  top: var(--topbarH);
  z-index: 950;
}

/* Solo la tabella A diventa area scroll */
#wrapA{
  overflow-y: auto !important;
  overflow-x: hidden !important;
  max-height: calc(var(--vh) - var(--topbarH) - var(--sectionAH));
  overscroll-behavior: contain;
  -webkit-overflow-scrolling: touch;
  background:#fff;
}

/* Intestazione colonne tabella A fissa dentro lo scroll del wrapper */
#tableA thead th{
  position: sticky;
  top: 0;
  z-index: 10;
}

/* Piccolo stacco visivo quando appiccicato */
#sectionHeaderA{
  box-shadow: 0 2px 0 rgba(0,0,0,0.15);
}
#tableA thead th{
  box-shadow: 0 2px 0 rgba(0,0,0,0.12);
}


/* === FIX DEFINITIVO SPAZIO BIANCO SOPRA HEADER TABELLA A === */

/* il wrapper A diventa nero (√® quello che "bucava") */
#wrapA{
  background:#000 !important;
  padding-top:0 !important;
}

/* la tabella resta bianca solo nel corpo */
#tableA{
  background:#fff;
}

/* tappo nero completo per intestazione */
#tableA thead,
#tableA thead tr,
#tableA thead th{
  background:#000 !important;
}


/* === SCROLL SOLO ATLETI + HEADER FISSO PER TABELLA B === */
#wrapB{
  overflow-y: auto !important;
  overflow-x: hidden !important;
  max-height: calc(var(--vh) - var(--topbarH) - var(--sectionBH));
  overscroll-behavior: contain;
  -webkit-overflow-scrolling: touch;
  background:#000 !important; /* tappo dietro header */
  padding-top:0 !important;
}
#tableB{ background:#fff; }
#tableB thead, #tableB thead tr, #tableB thead th{ background:#000 !important; }
#tableB thead th{
  position: sticky;
  top: 0;
  z-index: 10;
}


/* === DISTACCO VISIVO BLU TRA HEADER FISSO E TABELLE (A + B) === */
:root{
  --sticky-sep-blue: #0b3c5d; /* blu scuro elegante */
}

/* area sopra le intestazioni (ex nera) */
#wrapA,
#wrapB{
  background: var(--sticky-sep-blue) !important;
}

/* intestazioni tabelle */
#tableA thead,
#tableA thead tr,
#tableA thead th,
#tableB thead,
#tableB thead tr,
#tableB thead th{
  background: var(--sticky-sep-blue) !important;
  color:#fff;
}


/* === UX: colonna # cliccabile (mano) === */
th.sortable-num{
  cursor: pointer;
  user-select: none;
}
th.sortable-num:hover{
  background: rgba(255,255,255,0.15);
}


/* === HOME BUTTON === */
.topbar{ padding-right: calc(54px + env(safe-area-inset-right)); }
.home-topbar{
  position:absolute;
  top: calc(6px + env(safe-area-inset-top));
  right:8px;
  height:32px;
  line-height:32px;
  padding:0 10px;
  font-size:15px;
  font-weight:900;
  border:none;
  border-radius:6px;
  background:#e74c3c;
  color:#fff;
  cursor:pointer;
  z-index:1200;
}
.home-topbar:hover{ filter:brightness(1.1); }
.home-topbar:active{ transform:scale(.96); }


/* === TOPBAR DESTRA: seconda riga tutta a destra (stabile) === */
.rc-bottom{
  flex-basis: 100%;        /* forza nuova riga */
  display:flex;
  gap:6px;
  justify-content:flex-end; /* tutta a destra */
  flex-wrap:wrap;           /* se non entra, va a capo ma resta a destra */
}
@media (max-width: 980px){
  .rc-bottom{ justify-content:center; }
}


.subtitle{
  display:block !important;
  text-align:center;
  font-size:14px;
  margin-top:4px;
  color:#555;
}

/* =========================
   MODALE SELEZIONE PERIODO STATS (no prompt)
========================= */
#periodPickOverlay{
  display:none;
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  z-index:11000;
  align-items:center;
  justify-content:center;
  padding: calc(16px + env(safe-area-inset-bottom)) calc(16px + env(safe-area-inset-right)) calc(16px + env(safe-area-inset-bottom)) calc(16px + env(safe-area-inset-left));
}
#periodPickOverlay .box{
  width:min(520px, 100%);
  background:#fff;
  border-radius:14px;
  box-shadow:0 10px 40px rgba(0,0,0,.25);
  overflow:hidden;
  border:1px solid #eee;
}
#periodPickOverlay .hdr{
  padding:12px 14px;
  font-weight:900;
  border-bottom:1px solid #eee;
  background:#000;
  color:#fff;
}
#periodPickOverlay .body{
  padding:14px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
#periodPickOverlay label{
  font-size:13px;
  font-weight:800;
}
#periodPickOverlay select{
  height:40px;
  padding:0 10px;
  border:1px solid #ddd;
  border-radius:10px;
  font-size:14px;
  font-weight:800;
  background:#fff;
}
#periodPickOverlay .hint{
  font-size:12px;
  opacity:.75;
  line-height:1.35;
}
#periodPickOverlay .actions{
  display:flex;
  justify-content:flex-end;
  gap:8px;
  padding:12px 14px;
  border-top:1px solid #eee;
  background:#fafafa;
}



/* =========================
   iPad / iOS Safari TOUCH FIXES
   - evita zoom su input (font >=16)
   - migliora affidabilit√† tap dentro aree scroll
   - abilita selezione/scroll senza "blocchi"
========================= */
html, body{ height:100%; }
body{
  -webkit-text-size-adjust: 100%;
  -webkit-touch-callout: none;
}
button, [role="button"], .io-btn, .esp-btn, th.sortable-num, th[data-stats-key]{
  touch-action: manipulation;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
}
input, select, textarea{
  font-size:16px; /* iOS: sotto 16px -> zoom automatico */
}

</style>

</head>

<body>
<div class="subtitle" style="text-align:center;margin-bottom:6px;">sandro@systemdata.it</div>

<div class="topbar">
  <button class="home-topbar" onclick="goHome()" title="Torna al cruscotto">üè†</button>

  <!-- SINISTRA (quarti) -->
  <div class="side-spacer">
    <div class="left-pack">
      <div class="qcol-left">
        <div class="qrow"><strong>Q1</strong><span id="q1a">‚Äî</span><span id="q1b">‚Äî</span></div>
        <div class="qrow"><strong>Q2</strong><span id="q2a">‚Äî</span><span id="q2b">‚Äî</span></div>
        <div class="qrow"><strong>Q3</strong><span id="q3a">‚Äî</span><span id="q3b">‚Äî</span></div>
        <div class="qrow"><strong>Q4</strong><span id="q4a">‚Äî</span><span id="q4b">‚Äî</span></div>
        <div id="otRows"></div>
      </div>
    </div>
  </div>

  <!-- CENTRO -->
  <div class="center">
    <div id="clock">10:00</div>

    <div class="clock-controls">
      <button class="green" onclick="startClock()">‚ñ∂ Start</button>
      <button class="gray" onclick="stopClock()">‚è∏ Stop</button>
    </div>

    <div class="quarter-label" onclick="nextQuarter()">
      Periodo: <span id="qNum">1</span>
    </div>

    <div class="score-row">
      <div class="team-box">
        <input id="nameA" value="Squadra A" autocomplete="off" />
        <div class="team-fsq"><span id="teamFoulsA">0</span></div>
<div class="score-quick" aria-label="Punti rapidi Squadra A">
          <div class="row">
            <button class="blue" onclick="adjPts('A',1)">+1</button>
            <button class="blue" onclick="adjPts('A',2)">+2</button>
            <button class="blue" onclick="adjPts('A',3)">+3</button>
          
            <button class="red" onclick="adjTeamFouls('A',1)">+F</button>
          </div>
        </div>
      </div>

      <div class="score-big">
        <span id="scoreA">0</span> ‚Äì <span id="scoreB">0</span>
      </div>

      <div class="team-box">
        <input id="nameB" value="Squadra B" autocomplete="off" />
        <div class="team-fsq"><span id="teamFoulsB">0</span></div>
<div class="score-quick" aria-label="Punti rapidi Squadra B">
          <div class="row">
            <button class="blue" onclick="adjPts('B',1)">+1</button>
            <button class="blue" onclick="adjPts('B',2)">+2</button>
            <button class="blue" onclick="adjPts('B',3)">+3</button>
          
            <button class="red" onclick="adjTeamFouls('B',1)">+F</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- DESTRA -->
  <div class="undo" id="undoBox">
    <div class="right-controls">

      <button class="blue" onclick="saveGame()">üíæ Salva</button>
      <button class="blue data-toggle" id="matchDataBtn" onclick="toggleMatchData()">üìù Dati partita</button>
      <button class="gray" onclick="loadGameFromFile()" title="Carica da file JSON">üìÇ Carica</button>
      <div class="rc-bottom">
        <button class="gray" onclick="openGamesLibrary()" title="Libreria partite">üìö Partite</button>
        <button class="gray" onclick="newGame()">üÜï Nuovo</button>
        <button class="gray" onclick="openStats()" title="Statistiche">üìä Stats</button>
      </div>

</div>
<div id="matchDataPanel" class="match-data-panel" style="display:none;">
      <div class="match-data-grid">
        <div class="match-row"><label>CATEGORIA:</label><input id="campionato" autocomplete="off" placeholder="Es. U14" /></div>
        <div class="match-row"><label>GIRONE:</label><input id="girone" autocomplete="off" placeholder="Es. A" /></div>
        <div class="match-row"><label>DATA:</label><input id="dataGara" autocomplete="off" placeholder="GG/MM/AAAA" inputmode="numeric" /></div>
        <div class="match-row"><label>GIORNATA:</label><input id="giornata" type="number" min="1" step="1" autocomplete="off" placeholder="1" /></div>
        <div class="match-row"><label>A/R:</label><input id="andataRitorno" maxlength="1" autocomplete="off" placeholder="A o R" /></div>
        <div class="match-row"><label>CASA/FUORI:</label><input id="casaFuori" maxlength="1" autocomplete="off" placeholder="C o F" /></div>
        <div class="match-row"><label>ARBITRO 1:</label><input id="arbitro1" autocomplete="off" placeholder="Nome" /></div>
        <div class="match-row"><label>ARBITRO 2:</label><input id="arbitro2" autocomplete="off" placeholder="Nome" /></div>
        <div class="match-row">
          <label>LOGHI:</label>
          <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap; width:100%;">
            <input id="logoAInput" type="file" accept="image/*" style="display:none" />
            <input id="logoBInput" type="file" accept="image/*" style="display:none" />

            <button class="blue" type="button" onclick="pickLogo('A')" title="Carica logo Squadra A">üìé Logo A</button>
            <button class="gray" type="button" onclick="clearLogo('A')" title="Rimuovi logo Squadra A">‚úñ A</button>
            <img id="logoAPrev" alt="Logo A" style="width:28px;height:28px;object-fit:contain;border:1px solid #333;border-radius:6px;background:#000;display:none;" />

            <button class="blue" type="button" onclick="pickLogo('B')" title="Carica logo Squadra B">üìé Logo B</button>
            <button class="gray" type="button" onclick="clearLogo('B')" title="Rimuovi logo Squadra B">‚úñ B</button>
            <img id="logoBPrev" alt="Logo B" style="width:28px;height:28px;object-fit:contain;border:1px solid #333;border-radius:6px;background:#000;display:none;" />

            <button class="gray" type="button" onclick="clearLogo('ALL')" title="Rimuovi entrambi i loghi">üßπ Reset</button>
          </div>
        </div>

      </div>
    </div>

    <button class="gray" onclick="undo()">‚Ü© Undo</button>
    <div id="undoInfo" class="undo-info">‚Äî</div>
  </div>
</div>

<!-- ===== HEADER SQUADRA A ===== -->
<div class="section-header" id="sectionHeaderA">
  <div class="section-title" id="sectionTitleA">Squadra A</div>

  <div class="clock-system-mid" aria-label="Sistema cronometro">
    <button class="blue" onclick="nudgeClock(1)" title="+1s">+1</button>
    <button class="gray" onclick="nudgeClock(-1)" title="-1s">-1</button>
    <button class="blue" onclick="nudgeClock(60)" title="+60s">+60</button>
    <button class="gray" onclick="nudgeClock(-60)" title="-60s">-60</button>
  </div>

  <div class="section-controls">
    <div class="stat">PPS <span id="teamAPP">0</span> <button class="red" onclick="teamStat('A','pp')">+</button></div>
    <div class="stat">PRS <span id="teamAPR">0</span> <button class="green" onclick="teamStat('A','pr')">+</button></div>
    <div class="stat">TO <span id="teamATO">0</span>/<span id="teamATOMax">2</span> <button class="blue" onclick="teamTimeout('A')">+</button></div>
    <div class="stat">FTS <span id="teamAFTS">0</span></div>  </div>

  <button class="gray furbo-push" id="minusBtn" onclick="toggleMinus()" title="Furbo = correggi il prossimo +">üõ†Ô∏è Furbo</button>
</div>

<!-- TABELLA A -->
<div class="wrapper table-scroll" id="wrapA">
  <table id="tableA">
    <colgroup>
      <col class="c-num">
      <col class="c-name">
      <col class="c-pts">
      <col class="c-ff">
      <col class="c-min">
      <col class="c-pm">
      <col class="c-shot">
      <col class="c-shot">
      <col class="c-shot">
      <col class="c-stat"><col class="c-stat"><col class="c-stat"><col class="c-stat">
      <col class="c-stat"><col class="c-stat"><col class="c-stat"><col class="c-stat">
    </colgroup>
    <thead>
      <tr>
        <th class="sortable-num" data-dir="asc">#</th><th>Atleta</th><th>PTS</th><th>FF</th><th>MIN</th><th>P/M</th>
        <th>2PT</th><th>3PT</th><th>TL</th>
        <th>FS</th><th>RA</th><th>RD</th><th>A</th>
        <th>PP</th><th>PR</th><th>STf</th><th>STs</th>
      </tr>
    </thead>
    <tbody id="tbodyA"></tbody>
  </table>
</div>

<!-- ===== HEADER SQUADRA B ===== -->
<div class="section-header" id="sectionHeaderB">
  <div class="section-title" id="sectionTitleB">Squadra B</div>

  <div class="section-controls">
    <div class="stat">PPS <span id="teamBPP">0</span> <button class="red" onclick="teamStat('B','pp')">+</button></div>
    <div class="stat">PRS <span id="teamBPR">0</span> <button class="green" onclick="teamStat('B','pr')">+</button></div>
    <div class="stat">TO <span id="teamBTO">0</span>/<span id="teamBTOMax">2</span> <button class="blue" onclick="teamTimeout('B')">+</button></div>
    <div class="stat">FTS <span id="teamBFTS">0</span></div>  </div>
</div>

<!-- TABELLA B -->
<div class="wrapper" id="wrapB">
  <table id="tableB">
    <colgroup>
      <col class="c-num">
      <col class="c-name">
      <col class="c-pts">
      <col class="c-ff">
      <col class="c-min">
      <col class="c-pm">
      <col class="c-shot">
      <col class="c-shot">
      <col class="c-shot">
      <col class="c-stat"><col class="c-stat"><col class="c-stat"><col class="c-stat">
      <col class="c-stat"><col class="c-stat"><col class="c-stat"><col class="c-stat">
    </colgroup>
    <thead>
      <tr>
        <th class="sortable-num" data-dir="asc">#</th><th>Atleta</th><th>PTS</th><th>FF</th><th>MIN</th><th>P/M</th>
        <th>2PT</th><th>3PT</th><th>TL</th>
        <th>FS</th><th>RA</th><th>RD</th><th>A</th>
        <th>PP</th><th>PR</th><th>STf</th><th>STs</th>
      </tr>
    </thead>
    <tbody id="tbodyB"></tbody>
  </table>
</div>

<!-- ===== OVERLAY STATISTICHE ===== -->
<div id="statsOverlay" onclick="overlayClickClose(event)">
  <div id="statsPanel" onclick="event.stopPropagation()">
    <div id="statsHeader">
      <div id="statsScoreLine" class="score-line">‚Äî</div>

      <div class="stats-meta">
        <div id="statsMetaInfo" class="stats-meta-block">‚Äî</div>
        <div id="statsMetaQuarters" class="stats-meta-block">‚Äî</div>
      </div>

      <div class="spacer"></div>
      <button class="gray" onclick="showQuarterStats()">üïí Quarto</button>
      <button class="gray" onclick="showTotalStats()">Œ£ Totale</button>
      <button class="blue" onclick="shareGame()">üì§ Condividi</button>
      <button class="gray" onclick="shareResultCard()" title="Condividi solo risultato e parziali">üñºÔ∏è Solo risultato</button>
      <button class="red" onclick="exportStatsPDF()">‚¨áÔ∏è PDF</button>
      <button class="gray" onclick="closeStats()">‚úñ Chiudi</button>
    </div>
    <div id="statsBody"></div>
  </div>
</div>

<!-- ===== OVERLAY LIBRERIA PARTITE ===== -->
<div id="gamesOverlay" onclick="closeGamesLibrary()">
  <div id="gamesPanel" onclick="event.stopPropagation()">
    <div id="gamesHeader">
      <div class="title">Libreria Partite</div>
      <div class="spacer"></div>
      <button class="blue" onclick="exportLibraryBundle()">‚¨áÔ∏è Export</button>
      <button class="blue" onclick="importLibraryBundle()">‚¨ÜÔ∏è Import</button>
      <button class="gray" onclick="closeGamesLibrary()">‚úñ Chiudi</button>
    </div>

    <div id="gamesBody">
      <div class="lib-actions">
        <button class="blue" onclick="importManyGames()">‚¨ÜÔ∏è Import multiplo (.json)</button>
        <button class="gray" onclick="clearLibraryConfirm()">üóëÔ∏è Svuota libreria</button>
        <div id="libInfo">‚Äî</div>
      </div>

      <table class="lib-table">
        <thead>
          <tr>
            <th style="width:240px;">Nome</th>
            <th style="width:110px; text-align:center;">Data</th>
            <th>Avversario</th>
            <th style="width:250px; text-align:center;">Azioni</th>
          </tr>
        </thead>
        <tbody id="gamesTbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js">
/* === SORT PER COLONNA # (numero maglia) === */
function sortByNumber(side){
  const arr = (side === 'A') ? playersA : playersB;
  const th = document.querySelector(`#table${side} thead th.sortable-num`);
  const dir = th.getAttribute('data-dir') === 'asc' ? 1 : -1;

  const hasIn = arr.some(p => !!p.in);

  arr.sort((a,b)=>{
    // se esistono giocatori IN, portali in alto
    if(hasIn && a.in !== b.in){
      return a.in ? -1 : 1;
    }
    // poi ordina sempre per numero maglia
    return (Number(a.num||0) - Number(b.num||0)) * dir;
  });

  th.setAttribute('data-dir', dir === 1 ? 'desc' : 'asc');
  render();
}

document.addEventListener('click', (e)=>{
  const th = e.target.closest('th.sortable-num');
  if(!th) return;
  const table = th.closest('table');
  if(table?.id === 'tableA') sortByNumber('A');
  if(table?.id === 'tableB') sortByNumber('B');
});


/* === STATS: ordinamento cliccabile (solo overlay, non cambia le tabelle live) === */
const statsSort = {
  A: { key: 'num', dir: 1 },
  B: { key: 'num', dir: 1 },
};
const STATS_KEYS = new Set(['num','name','pts','ff','min','pmr','t2','t2p','t3','t3p','tl','tlp','fs','ra','rd','a','pp','pr','stf','sts','pir','oer','pm']); // pmr = P/M (pts/min)

function getStatValue(p, key){
  switch(key){
    case 'num': return Number(p.num||0);
    case 'name': return String(p.name||'').toLowerCase();
    case 'pts': return Number(p.pts||0);
    case 'ff': return Number(p.ff||0);
    case 'min': return Number(p.min||0);
    case 'pmr': {
      const secPlayed = Math.max(0, Number(p?.min) || 0);
      const minPlayed = secPlayed / 60;
      if(minPlayed <= 0) return -Infinity;
      return (Number(p?.pts)||0) / minPlayed;
    }
    case 'pir': return Number(calcPIR(p)||0);
    case 'oer': return Number(calcOER(p)||0);
    case 'pm':  return Number(p.pm||0);
    
    case 't2':  return numPct(p['2pt']?.made||0, p['2pt']?.att||0);
    case 't2p': return numPct(p['2pt']?.made||0, p['2pt']?.att||0);
    case 't3':  return numPct(p['3pt']?.made||0, p['3pt']?.att||0);
    case 't3p': return numPct(p['3pt']?.made||0, p['3pt']?.att||0);
    case 'tl':  return numPct(p.tl?.made||0, p.tl?.att||0);
    case 'tlp': return numPct(p.tl?.made||0, p.tl?.att||0);
    case 'fs':  return Number(p.fs||0);
    case 'ra':  return Number(p.ra||0);
    case 'rd':  return Number(p.rd||0);
    case 'a':   return Number(p.a||0);
    case 'pp':  return Number(p.pp||0);
    case 'pr':  return Number(p.pr||0);
    case 'stf': return Number(p.stf||0);
    case 'sts': return Number(p.sts||0);
    default: return 0;
  }
}

function sortForStats(side, arr){
  const s = statsSort[side] || {key:'num', dir:1};
  const key = s.key, dir = s.dir;
  const copy = [...arr];
  copy.sort((a,b)=>{
    const va = getStatValue(a, key);
    const vb = getStatValue(b, key);
    if(typeof va === 'string' || typeof vb === 'string'){
      return String(va).localeCompare(String(vb)) * dir;
    }
    return (va - vb) * dir;
  });
  return copy;
}

document.addEventListener('click', (e)=>{
  const th = e.target.closest?.('th[data-stats-key]');
  if(!th) return;
  const side = th.getAttribute('data-side');
  const key = th.getAttribute('data-stats-key');
  if(!side || !STATS_KEYS.has(key)) return;

  const cur = statsSort[side] || {key:'num', dir:1};
  if(cur.key === key){
    cur.dir = cur.dir * -1;
  } else {
    cur.key = key;
    cur.dir = 1;
  }
  statsSort[side] = cur;

  if(document.getElementById('statsOverlay').style.display === 'block'){
    renderStats();
  }
});


function getPeriodSplits(side){
  const out = [];
  for(let q=1;q<=4;q++){
    const el = document.getElementById(`q${q}${side.toLowerCase()}`);
    if(el) out.push({label:`Q${q}`, val: el.textContent});
  }
  const otHost = document.getElementById('otRows');
  if(otHost){
    const spans = otHost.querySelectorAll(`span[id^="ot"][id$="${side.toLowerCase()}"]`);
    const items = [...spans].map(sp=>{
      const m = sp.id.match(/^ot(\d+)[ab]$/);
      return {n: m?Number(m[1]):999, el: sp};
    }).sort((a,b)=>a.n-b.n);
    items.forEach(it=> out.push({label:`OT${it.n}`, val: it.el.textContent}));
  }
  return out;
}

function renderSplitsLine(side){
  const splits = getPeriodSplits(side).filter(x=> (x.val ?? '‚Äî') !== '‚Äî');
  if(!splits.length) return '<span class="lib-ellipsis">Parziali: ‚Äî</span>';
  const txt = splits.map(s=>`${s.label}:${s.val}`).join('  ‚Ä¢  ');
  return `<span class="lib-ellipsis">Parziali: ${escHtml(txt)}</span>`;
}

</script>
<script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js">
/* === SORT PER COLONNA # (numero maglia) === */
function sortByNumber(side){
  const arr = (side === 'A') ? playersA : playersB;
  const th = document.querySelector(`#table${side} thead th.sortable-num`);
  const dir = th.getAttribute('data-dir') === 'asc' ? 1 : -1;

  const hasIn = arr.some(p => !!p.in);

  arr.sort((a,b)=>{
    // se esistono giocatori IN, portali in alto
    if(hasIn && a.in !== b.in){
      return a.in ? -1 : 1;
    }
    // poi ordina sempre per numero maglia
    return (Number(a.num||0) - Number(b.num||0)) * dir;
  });

  th.setAttribute('data-dir', dir === 1 ? 'desc' : 'asc');
  render();
}

document.addEventListener('click', (e)=>{
  const th = e.target.closest('th.sortable-num');
  if(!th) return;
  const table = th.closest('table');
  if(table?.id === 'tableA') sortByNumber('A');
  if(table?.id === 'tableB') sortByNumber('B');
});

</script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<script>
/* ===========================
   UTIL
=========================== */

/* ===========================
   STATS SORT (FIX ROBUSTO)
   Nota: in HTML alcuni <script src="..."> contenevano codice inline (che il browser IGNORA).
   Qui mettiamo l'ordinamento in un blocco JS sicuro, unico, e valido per TUTTE le colonne Stats.
=========================== */
window.__statsSortInit = window.__statsSortInit || (function(){
  // stato ordinamento per squadra
  window.statsSort = window.statsSort || { A:{key:'num',dir:1}, B:{key:'num',dir:1} };

  // helpers percentuali (per ordinare su % e non sul testo)
  window.numPct = window.numPct || function(made, att){
    att = Number(att||0); made = Number(made||0);
    if(att <= 0) return -Infinity; // cos√¨ chi ha 0 tentativi va in fondo quando ordini desc
    return (made/att)*100;
  };

  // valore numerico/stringa per colonna
  window.getStatValue = function(p, key){
    switch(String(key||'')){
      case 'num': return Number(p?.num||0);
      case 'name': return String(p?.name||'').toLowerCase();
      case 'pts': return Number(p?.pts||0);
      case 'ff':  return Number(p?.ff||0);
      case 'min': return Number(p?.min||0);
      case 'pmr': {
        const m = (Number(p?.min)||0)/60;
        return m>0 ? (Number(p?.pts)||0)/m : -Infinity;
      }
      case 'pir': return Number((window.calcPIR ? calcPIR(p) : 0) || 0);
      case 'oer': return Number((window.calcOER ? calcOER(p) : 0) || 0);
      case 'pm':  return Number(p?.pm||0);

      // colonne tiri / % (Stats)
      case 't2':  return window.numPct(p?.['2pt']?.made||0, p?.['2pt']?.att||0);
      case 't2p': return window.numPct(p?.['2pt']?.made||0, p?.['2pt']?.att||0);
      case 't3':  return window.numPct(p?.['3pt']?.made||0, p?.['3pt']?.att||0);
      case 't3p': return window.numPct(p?.['3pt']?.made||0, p?.['3pt']?.att||0);
      case 'tl':  return window.numPct(p?.tl?.made||0, p?.tl?.att||0);
      case 'tlp': return window.numPct(p?.tl?.made||0, p?.tl?.att||0);

      // altre stats
      case 'fs':  return Number(p?.fs||0);
      case 'ra':  return Number(p?.ra||0);
      case 'rd':  return Number(p?.rd||0);
      case 'a':   return Number(p?.a||0);
      case 'pp':  return Number(p?.pp||0);
      case 'pr':  return Number(p?.pr||0);
      case 'stf': return Number(p?.stf||0);
      case 'sts': return Number(p?.sts||0);
      default: return 0;
    }
  };

  window.sortForStats = function(side, arr){
    const s = window.statsSort?.[side] || {key:'num',dir:1};
    const out = Array.isArray(arr) ? [...arr] : [];
    const key = s.key, dir = s.dir;

    out.sort((a,b)=>{
      const va = window.getStatValue(a, key);
      const vb = window.getStatValue(b, key);
      // stringhe
      if(typeof va === 'string' || typeof vb === 'string'){
        return String(va).localeCompare(String(vb)) * dir;
      }
      return (va - vb) * dir;
    });
    return out;
  };

  // listener unico: ordina SOLO quando overlay stats √® aperto
  document.addEventListener('click', (e)=>{
    const th = e.target?.closest?.('th[data-stats-key]');
    if(!th) return;

    const overlay = document.getElementById('statsOverlay');
    if(!overlay || overlay.style.display !== 'block') return;

    const side = th.getAttribute('data-side');
    const key  = th.getAttribute('data-stats-key');
    if(!side || !key) return;

    const cur = window.statsSort?.[side] || {key:'num',dir:1};
    if(cur.key === key){ cur.dir *= -1; } else { cur.key = key; cur.dir = 1; }
    window.statsSort[side] = cur;

    try{ window.renderStats && renderStats(); }catch(_){}
  }, true);

  return true;
})();


/* === STATS SORT HELPERS (GLOBAL) === */
/* === STATS SPLITS HELPERS (GLOBAL) === */
window.getPeriodSplits = window.getPeriodSplits || function(side){
  const out = [];
  for(let q=1;q<=4;q++){
    const el = document.getElementById(`q${q}${side.toLowerCase()}`);
    if(el) out.push({label:`Q${q}`, val: el.textContent});
  }
  const otHost = document.getElementById('otRows');
  if(otHost){
    const spans = otHost.querySelectorAll(`span[id^="ot"][id$="${side.toLowerCase()}"]`);
    const items = [...spans].map(sp=>{
      const m = sp.id.match(/^ot(\d+)[ab]$/);
      return {n: m?Number(m[1]):999, el: sp};
    }).sort((a,b)=>a.n-b.n);
    items.forEach(it=> out.push({label:`OT${it.n}`, val: it.el.textContent}));
  }
  return out;
};

window.renderSplitsLine = window.renderSplitsLine || function(side){
  const splits = window.getPeriodSplits(side).filter(x=> (x.val ?? '‚Äî') !== '‚Äî');
  if(!splits.length) return '<span class="lib-ellipsis">Parziali: ‚Äî</span>';
  const txt = splits.map(s=>`${s.label}:${s.val}`).join('  ‚Ä¢  ');
  // escHtml esiste gi√† nel file
  return `<span class="lib-ellipsis">Parziali: ${escHtml(txt)}</span>`;
};

window.statsSort = window.statsSort || { A:{key:'num',dir:1}, B:{key:'num',dir:1} };

window.getStatValue = window.getStatValue || function(p, key){
  switch(key){
    case 'num': return Number(p?.num||0);
    case 'name': return String(p?.name||'').toLowerCase();
    case 'pts': return Number(p?.pts||0);
    case 'ff': return Number(p?.ff||0);
    case 'min': return Number(p?.min||0);
    case 'pmr': {
      const m = (Number(p?.min)||0)/60;
      return m>0 ? (Number(p?.pts)||0)/m : -Infinity;
    }
    case 'pir': return Number(calcPIR(p)||0);
    case 'oer': return Number(calcOER(p)||0);
    case 'pm':  return Number(p?.pm||0);
    
    case 't2':  return numPct(p['2pt']?.made||0, p['2pt']?.att||0);
    case 't2p': return numPct(p['2pt']?.made||0, p['2pt']?.att||0);
    case 't3':  return numPct(p['3pt']?.made||0, p['3pt']?.att||0);
    case 't3p': return numPct(p['3pt']?.made||0, p['3pt']?.att||0);
    case 'tl':  return numPct(p.tl?.made||0, p.tl?.att||0);
    case 'tlp': return numPct(p.tl?.made||0, p.tl?.att||0);
    case 'fs':  return Number(p.fs||0);
    case 'ra':  return Number(p.ra||0);
    case 'rd':  return Number(p.rd||0);
    case 'a':   return Number(p.a||0);
    case 'pp':  return Number(p.pp||0);
    case 'pr':  return Number(p.pr||0);
    case 'stf': return Number(p.stf||0);
    case 'sts': return Number(p.sts||0);
    default: return 0;
  }
};

window.sortForStats = window.sortForStats || function(side, arr){
  const s = window.statsSort?.[side] || {key:'num',dir:1};
  const out = Array.isArray(arr) ? [...arr] : [];
  out.sort((a,b)=>{
    const va = window.getStatValue(a,s.key);
    const vb = window.getStatValue(b,s.key);
    if(typeof va === 'string' || typeof vb === 'string'){
      return String(va).localeCompare(String(vb)) * s.dir;
    }
    return (va - vb) * s.dir;
  });
  return out;
};

document.addEventListener('click',(e)=>{
  const th = e.target.closest?.('th[data-stats-key]');
  if(!th) return;
  const side = th.getAttribute('data-side');
  const key  = th.getAttribute('data-stats-key');
  if(!side || !key) return;

  const cur = window.statsSort?.[side] || {key:'num',dir:1};
  if(cur.key === key){ cur.dir *= -1; } else { cur.key = key; cur.dir = 1; }
  window.statsSort[side] = cur;

  if(document.getElementById('statsOverlay')?.style.display === 'block'){
    try{ renderStats(); }catch(_){}
  }
});

function $id(id){ return document.getElementById(id); }

function updateSideWidth(){
  const undoBox = document.getElementById('undoBox');
  if(!undoBox) return;
  const w = Math.ceil(undoBox.getBoundingClientRect().width);
  document.documentElement.style.setProperty('--sideW', w + 'px');
  updateStickyOffsets();
}

function updateStickyOffsets(){
  const topbar = document.querySelector('.topbar');
  const headerA = document.getElementById('sectionHeaderA');
  const headerB = document.getElementById('sectionHeaderB');

  const topH = topbar ? Math.ceil(topbar.getBoundingClientRect().height) : 0;
  const headAH = headerA ? Math.ceil(headerA.getBoundingClientRect().height) : 0;
  const headBH = headerB ? Math.ceil(headerB.getBoundingClientRect().height) : 0;

  document.documentElement.style.setProperty('--topbarH', topH + 'px');
  document.documentElement.style.setProperty('--sectionAH', headAH + 'px');
  document.documentElement.style.setProperty('--sectionBH', headBH + 'px');
}

window.addEventListener('resize', updateSideWidth);

function formatTime(sec){
  sec = Math.max(0, Math.floor(Number(sec) || 0));
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
}

function pointsPerMinute(p){
  const secPlayed = Math.max(0, Number(p?.min) || 0);
  const minutes = secPlayed / 60;
  const pts = Number(p?.pts) || 0;
  if(minutes <= 0) return '‚Äî';
  const v = pts / minutes;
  // 2 decimali, stile italiano con punto (pi√π compatto)
  return v.toFixed(2);
}

function statsPM(p){
  const secPlayed = Math.max(0, Number(p?.min) || 0);
  const minPlayed = secPlayed / 60;
  const pts = Number(p?.pts) || 0;
  if(minPlayed <= 0) return '‚Äî';
  return (pts / minPlayed).toFixed(2);
}

function pct(made, att){
  att = Number(att||0);
  made = Number(made||0);
  if(att <= 0) return '‚Äî';
  const v = (made/att)*100;
  return v.toFixed(1).replace('.', ',') + '%';
}

function numPct(made, att){
  att = Number(att||0);
  made = Number(made||0);
  if(att <= 0) return -Infinity;
  return (made/att)*100;
}


/* ===========================
   LOGHI (OFFLINE) ‚Äì embedded in localStorage as DataURL (base64)
   - pickLogo('A'/'B'): seleziona immagine locale e salva
   - clearLogo('A'/'B'/'ALL'): rimuove
   - usati in "Solo risultato" (shareResultCard) per il JPG
=========================== */
const LOGO_KEY_A = 'bs_logoA_dataurl';
const LOGO_KEY_B = 'bs_logoB_dataurl';

function getLogoData(side){
  const key = (side === 'A') ? LOGO_KEY_A : LOGO_KEY_B;
  return (localStorage.getItem(key) || '').trim();
}

function setLogoData(side, dataUrl){
  const key = (side === 'A') ? LOGO_KEY_A : LOGO_KEY_B;
  if(dataUrl) localStorage.setItem(key, dataUrl);
  else localStorage.removeItem(key);
  updateLogoPreviews();
}

function updateLogoPreviews(){
  const a = getLogoData('A');
  const b = getLogoData('B');

  const imgA = document.getElementById('logoAPrev');
  const imgB = document.getElementById('logoBPrev');

  if(imgA){
    if(a){ imgA.src = a; imgA.style.display = 'inline-block'; }
    else { imgA.removeAttribute('src'); imgA.style.display = 'none'; }
  }
  if(imgB){
    if(b){ imgB.src = b; imgB.style.display = 'inline-block'; }
    else { imgB.removeAttribute('src'); imgB.style.display = 'none'; }
  }
}

function pickLogo(side){
  const input = document.getElementById(side === 'A' ? 'logoAInput' : 'logoBInput');
  if(!input) return;
  input.value = '';
  input.onchange = () => {
    const file = input.files && input.files[0];
    if(!file) return;
    if(!file.type || !file.type.startsWith('image/')){
      alert('Seleziona un file immagine (PNG/JPG/WebP).');
      return;
    }
    const reader = new FileReader();
    reader.onload = () => {
      const dataUrl = String(reader.result || '').trim();
      if(!dataUrl.startsWith('data:image/')){
        alert('Immagine non valida.');
        return;
      }
      setLogoData(side, dataUrl);
    };
    reader.onerror = () => alert('Errore durante la lettura del file.');
    reader.readAsDataURL(file);
  };
  input.click();
}

function clearLogo(side){
  if(side === 'ALL'){
    setLogoData('A','');
    setLogoData('B','');
    return;
  }
  setLogoData(side,'');
}

// Aggiorna preview all'avvio
window.addEventListener('load', ()=>{ try{ updateLogoPreviews(); }catch(e){} });




function escAttr(s){
  return String(s ?? '')
    .replaceAll('&','&amp;')
    .replaceAll('"','&quot;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;');
}
function escHtml(s){
  return String(s ?? '')
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;');
}

/* ===========================
   TIMER ‚ÄúSICURO‚Äù
   - Wake Lock (anti-sleep schermo) se supportato
   - Beep a 0:00 (WebAudio)
=========================== */
let wakeLockSentinel = null;

async function requestWakeLock(){
  try{
    if(!('wakeLock' in navigator)) return;
    // evita doppia richiesta
    if(wakeLockSentinel && !wakeLockSentinel.released) return;
    wakeLockSentinel = await navigator.wakeLock.request('screen');
    wakeLockSentinel.addEventListener('release', ()=>{
      // rilascio gestito (stop/visibilit√†), ok
    });
  }catch(e){
    // silenzioso: alcuni browser bloccano senza interazione o in low-power mode
  }
}

async function releaseWakeLock(){
  try{
    if(wakeLockSentinel && !wakeLockSentinel.released){
      await wakeLockSentinel.release();
    }
  }catch(e){}
  wakeLockSentinel = null;
}

// Se la pagina torna visibile durante il timer, riprova a prendere il Wake Lock
document.addEventListener('visibilitychange', ()=>{
  if(document.visibilityState === 'visible' && timer){
    requestWakeLock();
  }
});

let audioCtx = null;

function ensureAudio(){
  try{
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if(audioCtx.state === 'suspended'){
      audioCtx.resume();
    }
  }catch(e){}
}

function beep(){
  try{
    ensureAudio();
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = 'sine';
    o.frequency.value = 880; // Hz
    g.gain.value = 0.0001;

    o.connect(g);
    g.connect(audioCtx.destination);

    const t = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.25, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.22);

    o.start(t);
    o.stop(t + 0.24);
  }catch(e){}
}


/* ===========================
   MODEL
=========================== */
function makePlayer(name, num){
  return {
    num: Number.isFinite(Number(num)) ? Number(num) : 0,
    name,
    in:false,
    expelled:false,
    pts:0, ff:0, min:0,
    '2pt':{made:0,att:0},
    '3pt':{made:0,att:0},
    tl:{made:0,att:0},
    fs:0,ra:0,rd:0,a:0,pp:0,pr:0,stf:0,sts:0,
    pm:0
  };
}
function normalizePlayers(list, n=12, prefix="Giocatore"){
  if(!Array.isArray(list)) list = [];
  list = list.map((p, idx)=>{
    const base = makePlayer(p?.name || `${prefix} ${idx+1}`, (p?.num ?? (idx+1)));
    const out = {...base, ...p};
    out['2pt'] = out['2pt'] || {made:0,att:0};
    out['3pt'] = out['3pt'] || {made:0,att:0};
    out.tl = out.tl || {made:0,att:0};
    if(typeof out.min !== 'number') out.min = 0;
    if(!Number.isFinite(Number(out.num))) out.num = idx+1;
    out.num = Math.max(0, Math.min(99, Math.floor(Number(out.num))));
    if(typeof out.pm !== 'number') out.pm = 0;
    if(typeof out.expelled !== 'boolean') out.expelled = false;
    if(typeof out.in !== 'boolean') out.in = false;
    if(typeof out.ff !== 'number') out.ff = 0;
    return out;
  });
  while(list.length < n) list.push(makePlayer(`${prefix} ${list.length+1}`, list.length+1));
  if(list.length > n) list = list.slice(0,n);
  return list;
}

const STORAGE_KEY = 'basket_stats_state_file_unico_v1';
const QUARTER_LEN = 600; // 10:00
const OT_LEN = 300;      // 5:00

let teamA = { pp:0, pr:0, to:0, fts:0 };
let teamB = { pp:0, pr:0, to:0, fts:0 };

let playersA = normalizePlayers([ makePlayer('Marco De Rosa',1), makePlayer('Luca Bianchi',2) ], 12, 'A');
let playersB = normalizePlayers([], 12, 'B');
playersA[0].in = true;

let undoStack = [];
let currentQuarter=1, lastScoreA=0, lastScoreB=0;
let sec=QUARTER_LEN, timer=null;
let minusMode = false;
let gameClosed = false; // true quando finisce Q4 senza parit√†
// ===== SNAPSHOT PER QUARTO (per stats 'solo periodo')
let periodSnapshots = {}; // es: { Q1:{playersA,playersB}, Q2:{...}, OT1:{...} }
let statsView = { mode:'total', label:null, A:null, B:null };
// Punti globali (+1/+2/+3) usa modalit√† Furbo (minusMode)

function adjPts(side, pts){
  if(gameClosed) return;
  pts = Math.trunc(Number(pts)||0);
  if(!(pts===1 || pts===2 || pts===3)) return;

  const delta = minusMode ? -pts : pts;

  // non permettere punteggio negativo
  const current = (sumTeam(getPlayers(side)).pts || 0) + (scoreAdj[side]||0);
  if(current + delta < 0) return;

  const oldAdj = scoreAdj[side] || 0;
  const pmA = playersA.map(x=>x.pm||0);
  const pmB = playersB.map(x=>x.pm||0);

  save(`Punti ${side} ${delta>0?'+':''}${delta}`, ()=>{
    scoreAdj[side] = oldAdj;
    playersA.forEach((x, idx)=> x.pm = pmA[idx] || 0);
    playersB.forEach((x, idx)=> x.pm = pmB[idx] || 0);
  });

  scoreAdj[side] = oldAdj + delta;
  applyPlusMinus(side, delta);

  render();
}





/* ===========================
   PERIODI / OT ROWS
=========================== */
function periodLabel(q){
  if(q <= 4) return String(q);
  return `OT ${q-4}`;
}
function ensureOtRow(otIndex){
  const idA = `ot${otIndex}a`;
  const idB = `ot${otIndex}b`;
  if(document.getElementById(idA) && document.getElementById(idB)) return;

  const host = document.getElementById('otRows');
  const row = document.createElement('div');
  row.className = 'qrow';
  row.innerHTML = `<strong>OT${otIndex}</strong><span id="${idA}">‚Äî</span><span id="${idB}">‚Äî</span>`;
  host.appendChild(row);
}
function rebuildOtRowsFromState(quartersObj){
  const host = document.getElementById('otRows');
  host.innerHTML = '';
  if(!quartersObj) return;
  const keys = Object.keys(quartersObj).filter(k=>/^ot\\d+[ab]$/.test(k));
  let maxOt = 0;
  keys.forEach(k=>{
    const m = k.match(/^ot(\\d+)[ab]$/);
    if(m) maxOt = Math.max(maxOt, Number(m[1]));
  });
  for(let i=1;i<=maxOt;i++){
    ensureOtRow(i);
    const a = document.getElementById(`ot${i}a`);
    const b = document.getElementById(`ot${i}b`);
    if(a && typeof quartersObj[`ot${i}a`] === 'string') a.textContent = quartersObj[`ot${i}a`];
    if(b && typeof quartersObj[`ot${i}b`] === 'string') b.textContent = quartersObj[`ot${i}b`];
  }
}

/* ===========================
   STATE SAVE/LOAD
=========================== */
function snapshotState(){
  const quarters = {
    q1a:q1a.textContent, q1b:q1b.textContent,
    q2a:q2a.textContent, q2b:q2b.textContent,
    q3a:q3a.textContent, q3b:q3b.textContent,
    q4a:q4a.textContent, q4b:q4b.textContent
  };
  const otHost = document.getElementById('otRows');
  if(otHost){
    const spans = otHost.querySelectorAll('span[id^="ot"]');
    spans.forEach(sp=>{ quarters[sp.id] = sp.textContent; });
  }

  return {
    teamA, teamB, playersA, playersB,
    currentQuarter, lastScoreA, lastScoreB,
    sec,
    scoreAdj,
    periodSnapshots,
    ui:{
      nameA: nameA.value ?? '',
      nameB: nameB.value ?? '',
      campionato: campionato.value ?? '',
      girone: girone.value ?? '',
      dataGara: dataGara.value ?? '',
      giornata: giornata.value ?? '',
      andataRitorno: andataRitorno.value ?? '',
      casaFuori: casaFuori.value ?? '',
      arbitro1: arbitro1.value ?? '',
      arbitro2: arbitro2.value ?? ''
    },
    quarters
  };
}
function saveState(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshotState())); }catch(e){} }

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return false;
    const s = JSON.parse(raw);

    if(s?.teamA) teamA = s.teamA;
    if(s?.teamB) teamB = s.teamB;
    if(Array.isArray(s?.playersA)) playersA = s.playersA;
    if(Array.isArray(s?.playersB)) playersB = s.playersB;

    if(typeof s?.currentQuarter === 'number') currentQuarter = s.currentQuarter;
    if(typeof s?.lastScoreA === 'number') lastScoreA = s.lastScoreA;
    if(typeof s?.lastScoreB === 'number') lastScoreB = s.lastScoreB;
    if(typeof s?.sec === 'number') sec = s.sec;

  if(s?.scoreAdj){ scoreAdj = { A: Number(s.scoreAdj.A||0), B: Number(s.scoreAdj.B||0) }; } else { scoreAdj = {A:0,B:0}; }
  if(s?.periodSnapshots && typeof s.periodSnapshots === 'object') periodSnapshots = s.periodSnapshots; else periodSnapshots = {};



  if(s?.scoreAdj){ scoreAdj = { A: Number(s.scoreAdj.A||0), B: Number(s.scoreAdj.B||0) }; } else { scoreAdj = {A:0,B:0}; }
    
    if(s?.periodSnapshots && typeof s.periodSnapshots === 'object'){
      periodSnapshots = s.periodSnapshots;
    }else{
      periodSnapshots = {};
    }
if(s?.ui){
      if(typeof s.ui.nameA === 'string') nameA.value = s.ui.nameA;
      if(typeof s.ui.nameB === 'string') nameB.value = s.ui.nameB;

      if(typeof s.ui.campionato === 'string') campionato.value = s.ui.campionato;
      if(typeof s.ui.girone === 'string') girone.value = s.ui.girone;
      if(typeof s.ui.dataGara === 'string') dataGara.value = s.ui.dataGara;
      if(typeof s.ui.giornata === 'string') giornata.value = s.ui.giornata;
      if(typeof s.ui.andataRitorno === 'string') andataRitorno.value = s.ui.andataRitorno;
      if(typeof s.ui.casaFuori === 'string') casaFuori.value = s.ui.casaFuori;
      if(typeof s.ui.arbitro1 === 'string') arbitro1.value = s.ui.arbitro1;
      if(typeof s.ui.arbitro2 === 'string') arbitro2.value = s.ui.arbitro2;
    }

    if(s?.quarters){
      for(const k of ['q1a','q1b','q2a','q2b','q3a','q3b','q4a','q4b']){
        const el = document.getElementById(k);
        if(el && typeof s.quarters[k] === 'string') el.textContent = s.quarters[k];
      }
      rebuildOtRowsFromState(s.quarters);
    }

    playersA = normalizePlayers(playersA, 12, 'A');
    playersB = normalizePlayers(playersB, 12, 'B');

    const fixMin = (arr)=>{
      sorted.forEach(p=>{
        const v = Number(p.min);
        if (!Number.isFinite(v)) { p.min = 0; return; }
        if (!Number.isInteger(v)) p.min = Math.round(v * 60);
        else p.min = v;
      });
    };
    fixMin(playersA); fixMin(playersB);

    teamA.to = Number(teamA.to||0); teamB.to = Number(teamB.to||0);
    teamA.fts = Number(teamA.fts||0); teamB.fts = Number(teamB.fts||0);

    playersA.forEach(p=>{
      if(typeof p.pm !== 'number') p.pm = 0;
      if(typeof p.expelled !== 'boolean') p.expelled = false;
      if(typeof p.in !== 'boolean') p.in = false;
    });
    playersB.forEach(p=>{
      if(typeof p.pm !== 'number') p.pm = 0;
      if(typeof p.expelled !== 'boolean') p.expelled = false;
      if(typeof p.in !== 'boolean') p.in = false;
    });

    return true;
  }catch(e){ return false; }
}

/* ===========================
   HELPERS
=========================== */

const MAX_ON_COURT = 5;
function countIn(side){
  return getPlayers(side).reduce((c,p)=> c + (p.in ? 1 : 0), 0);
}
function warnMaxIn(side){
  alert(`Blocco ‚Äú5 in campo‚Äù: massimo ${MAX_ON_COURT} giocatori IN per squadra.`);
}
function clampMaxIn(side){
  const arr = getPlayers(side);
  const inIdx = [];
  for(let i=0;i<arr.length;i++){ if(arr[i]?.in) inIdx.push(i); }
  if(inIdx.length <= MAX_ON_COURT) return;
  for(let k=MAX_ON_COURT;k<inIdx.length;k++) arr[inIdx[k]].in=false;
}

function getPlayers(side){ return side==='A' ? playersA : playersB; }
function getTeam(side){ return side==='A' ? teamA : teamB; }
function maxTimeouts(){ return (currentQuarter >= 4) ? 3 : 2; } // Q4 e OT -> 3
function isLocked(p){ return !!p.expelled || (Number(p.ff||0) >= 5); }
function can(side, i){
  const p = getPlayers(side)[i];
  return (p && (p.in || minusMode));
}

/* ===========================
   UNDO
=========================== */
function save(label, cb){
  undoStack.push({label, cb});
  undoInfo.textContent = 'Ultima azione: ' + label;
  updateSideWidth();
}
function undo(){
  if(!undoStack.length) return;
  undoStack.pop().cb();
  undoInfo.textContent = undoStack.at(-1)?.label || '‚Äî';
  render();
}

/* ===========================
   DATI PARTITA TOGGLE
=========================== */
function toggleMatchData(){
  const p = document.getElementById('matchDataPanel');
  const b = document.getElementById('matchDataBtn');
  if(!p || !b) return;

  const isOpen = (p.style.display !== 'none');
  p.style.display = isOpen ? 'none' : 'block';

  b.classList.toggle('gray', !isOpen);
  b.classList.toggle('blue', isOpen);

  updateSideWidth();
}

/* ===========================
   FURBO
=========================== */
function toggleMinus(){
  minusMode = !minusMode;
  document.getElementById('minusBtn').classList.toggle('active', minusMode);
}
function clearMinus(){
  if(!minusMode) return;
  minusMode = false;
  document.getElementById('minusBtn').classList.remove('active');
}

/* ===========================
   ESPULSIONE
=========================== */
function expelPlayer(side, i){
  const arr = getPlayers(side);
  const p = arr[i];
  if(!p) return;
  if(isLocked(p)) return;

  const oldExp = !!p.expelled;
  const oldIn  = !!p.in;

  save(`${side} ${p.name} ESP`, ()=>{
    p.expelled = oldExp;
    p.in = oldIn;
  });

  p.expelled = true;
  p.in = false;

  clearMinus();
  render();
}

/* ===========================
   SAVE GAME / NEW GAME
=========================== */
function safeFilenameBase(s){
  const t = String(s || '').trim();
  const cleaned = t
    .replaceAll(' ','_')
    .replaceAll(/[^a-zA-Z0-9_\\-]/g,'')
    .slice(0,50);
  return cleaned || 'partita';
}

// ===========================
// GAME ID (per associare Q1/Q2/Q3/Q4/OT.../FINAL)
// - rimane stabile per tutta la partita
// - viene scritto nei JSON (meta.gameId) cos√¨ il Viewer pu√≤ raggruppare i file
// ===========================
let CURRENT_GAME_ID = '';
let SNAPSHOT_STORE = { gameId:'', baseMeta:{}, snaps:{} };

function normToken(s){
  return String(s||'')
    .trim()
    .toUpperCase()
    .replaceAll('√Ä','A').replaceAll('√à','E').replaceAll('√â','E').replaceAll('√å','I').replaceAll('√í','O').replaceAll('√ô','U')
    .replaceAll(/[^A-Z0-9]+/g,'_')
    .replaceAll(/_+/g,'_')
    .replaceAll(/^_+|_+$/g,'');
}

function normDateIsoFromUI(){
  // dataGara √® GG/MM/AAAA (come da placeholder)
  const raw = String(dataGara?.value||'').trim();
  const m = raw.match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{4})$/);
  if(m){
    const dd = String(m[1]).padStart(2,'0');
    const mm = String(m[2]).padStart(2,'0');
    const yyyy = m[3];
    return `${yyyy}-${mm}-${dd}`;
  }
  // fallback: se gi√† in ISO o altro, lo normalizziamo "grezzo"
  return raw ? raw.replaceAll('/','-') : '';
}

function computeGameId(){
  const camp = normToken(campionato?.value||'');   // es: DR2 / U14
  const gir  = normToken(girone?.value||'');       // es: C
  const iso  = normDateIsoFromUI();                // es: 2026-02-06
  const aN   = normToken(nameA?.value||'SQUADRA_A');
  const bN   = normToken(nameB?.value||'SQUADRA_B');

  // forma: CAMP_GIR_YYYY-MM-DD_TEAM_A_vs_TEAM_B (girone opzionale)
  const head = [camp, gir].filter(Boolean).join('_');
  const core = [iso, aN, 'VS', bN].filter(Boolean).join('_');
  return normToken([head, core].filter(Boolean).join('_'));
}

function ensureGameId(){
  if(CURRENT_GAME_ID) return CURRENT_GAME_ID;
  CURRENT_GAME_ID = computeGameId();
  SNAPSHOT_STORE = { gameId: CURRENT_GAME_ID, baseMeta: (getMetaFromUI?getMetaFromUI():{}), snaps: {} };
  return CURRENT_GAME_ID;
}

function resetGameId(){
  CURRENT_GAME_ID = '';
  SNAPSHOT_STORE = { gameId:'', baseMeta:{}, snaps:{} };
}

function makeStandardFilename(gameId, snapshot){
  const stamp = new Date().toISOString().slice(0,19).replaceAll(':','-');
  return `${gameId}__${String(snapshot||'FINAL').toUpperCase()}__${stamp}.json`;
}

function getMetaFromUI(){
  const aName = (nameA.value || 'Squadra A').trim();
  const bName = (nameB.value || 'Squadra B').trim();
  const date = (dataGara.value || '').trim();
  const camp = (campionato.value || '').trim();
  const opponent = bName;
  const baseName = [camp, date, `${aName} vs ${bName}`].filter(Boolean).join(' ‚Ä¢ ');
  return { aName, bName, date, opponent, defaultName: baseName || `${aName} vs ${bName}` };
}
function promptGameName(defaultName){
  const raw = prompt('Nome partita da salvare:', defaultName);
  if(raw === null) return null;
  const name = raw.trim();
  return name.length ? name : defaultName;
}

function saveGame(){
  const finalScoreA = document.getElementById('scoreA')?.textContent ?? '0';
  const finalScoreB = document.getElementById('scoreB')?.textContent ?? '0';

  saveState();

  const meta = getMetaFromUI();
  const gameId = ensureGameId();
  // In alcuni wrapper .exe (WebView/Electron) prompt() pu√≤ non funzionare: usiamo un nome automatico come per Q1/Q2/Q3/Q4
  const gameName = meta.defaultName;

  saveGameToLibrary(gameName);

  const state = snapshotState();
  const payload = {
    __type: 'basket_stats_game',
    __version: 1,
    meta: {
      id: null,
      gameId: gameId,
      snapshot: 'FINAL',
      name: gameName,
      date: meta.date,
      aName: meta.aName,
      bName: meta.bName,
      opponent: meta.opponent,
      savedAt: new Date().toISOString(),
      scoreAName: meta.aName,
      scoreA: String(finalScoreA),
      scoreBName: meta.bName,
      scoreB: String(finalScoreB),
      score: `${meta.aName} ${finalScoreA} - ${finalScoreB} ${meta.bName}`,
      finalScoreA: String(finalScoreA),
      finalScoreB: String(finalScoreB),
      finalScore: `${finalScoreA}-${finalScoreB}`
    },
    state
  };
  // Aggiorna store e crea FILE UNICO MATCH
  SNAPSHOT_STORE.gameId = gameId;
  SNAPSHOT_STORE.baseMeta = meta || (getMetaFromUI?getMetaFromUI():{});
  SNAPSHOT_STORE.snaps['FINAL'] = payload;

  const bundle = {
    __type: 'basket_stats_match',
    __version: 1,
    meta: {
      gameId: gameId,
      aName: meta.aName,
      bName: meta.bName,
      scoreA: String(finalScoreA),
      scoreB: String(finalScoreB),
      title: `${meta.aName || 'Squadra A'} vs ${meta.bName || 'Squadra B'}`,
      date: meta.date || meta.data || '',
      createdAt: new Date().toISOString()
    },
    snapshots: SNAPSHOT_STORE.snaps
  };

  const json = JSON.stringify(bundle, null, 2);
  const filename = makeStandardFilename(gameId, 'MATCH');

  const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);

  undoInfo.textContent = 'Salvato file unico: ' + filename;
  updateSideWidth();
}

function newGame(){
  stopClock();
  resetGameId();
  gameClosed = false;
scoreAdj = {A:0,B:0};

  periodSnapshots = {};
  statsView = { mode:'total', label:null, A:null, B:null };

  const keepNameA = nameA.value;
  const keepRosterA = playersA.map(p => ({ name: p.name, num: p.num }));

  currentQuarter = 1;
  lastScoreA = 0;
  lastScoreB = 0;
  sec = QUARTER_LEN;

  for(const k of ['q1a','q1b','q2a','q2b','q3a','q3b','q4a','q4b']){
    const el = document.getElementById(k);
    if(el) el.textContent = '‚Äî';
  }
  document.getElementById('otRows').innerHTML = '';

  teamA = { pp:0, pr:0, to:0, fts:0 };
  teamB = { pp:0, pr:0, to:0, fts:0 };

  playersA = normalizePlayers(
    keepRosterA.map((p)=> makePlayer(p.name || 'A', p.num)),
    12,
    'A'
  );
  playersA.forEach(p=> { p.in = false; p.expelled = false; p.ff = 0; });
  playersA[0].in = true;

  nameB.value = 'Squadra B';
  playersB = normalizePlayers([], 12, 'B');
  playersB.forEach(p=> { p.in = false; p.expelled = false; p.ff = 0; });

  nameA.value = keepNameA;

  undoStack = [];
  undoInfo.textContent = '‚Äî';

  render();
}

/* ===========================
   PLUS/MINUS
=========================== */
function applyPlusMinus(scoringSide, ptsDelta){
  if(scoringSide === 'A'){
    playersA.forEach(p=>{ if(p.in) p.pm = (p.pm||0) + ptsDelta; });
    playersB.forEach(p=>{ if(p.in) p.pm = (p.pm||0) - ptsDelta; });
  } else {
    playersB.forEach(p=>{ if(p.in) p.pm = (p.pm||0) + ptsDelta; });
    playersA.forEach(p=>{ if(p.in) p.pm = (p.pm||0) - ptsDelta; });
  }
}

/* ===========================
   EDIT
=========================== */
function setPlayerName(side, i, val){
  const p = getPlayers(side)[i]; if(!p) return;
  p.name = (val ?? '').toString();
  saveState();
}
function setPlayerNum(side, i, val){
  const p = getPlayers(side)[i]; if(!p) return;
  let n = Number(val);
  if(!Number.isFinite(n)) n = 0;
  n = Math.max(0, Math.min(99, Math.floor(Number(n))));
  p.num = n;
  saveState();
}
function toggleIn(side, i){
  const p = getPlayers(side)[i]; if(!p) return;
  if(isLocked(p)) return;
  if(!p.in && countIn(side) >= MAX_ON_COURT){
    warnMaxIn(side);
    return;
  }
  p.in = !p.in;
  render();
}

/* ===========================
   TEAM STATS
=========================== */

// Falli di squadra rapidi (+/-) usando Furbo
function adjTeamFouls(side, delta){
  if(gameClosed) return;
  const t = getTeam(side);
  const old = t.fts || 0;
  const d = (minusMode ? -delta : delta);
  if(old + d < 0) return;

  save(`Falli squadra ${side} ${d>0?'+':''}${d}`, ()=>{
    t.fts = old;
  });
  t.fts = old + d;
  render();
}

function teamStat(side, key){
  const t = getTeam(side);
  const delta = minusMode ? -1 : 1;
  const old = t[key] || 0;
  if(old + delta < 0) return;

  save(`Squadra ${side} ${key}`, ()=> t[key] = old);
  t[key] = old + delta;

  clearMinus();
  render();
}
function teamTimeout(side){
  const t = getTeam(side);
  const max = maxTimeouts();
  const delta = minusMode ? -1 : 1;
  const old = t.to || 0;

  if(old + delta < 0) return;
  if(delta > 0 && old >= max) return;

  save(`Timeout squadra ${side}`, ()=> t.to = old);
  t.to = old + delta;

  clearMinus();
  render();
}

/* ===========================
   PLAYER STATS
=========================== */
function addStat(side, i, s, v){
  if(!can(side,i)) return;

  const arr = getPlayers(side);
  const t = getTeam(side);
  const p = arr[i];

  const delta = minusMode ? -v : v;
  if((p[s] ?? 0) + delta < 0) return;

  if(s === 'ff'){
    const oldFF = p.ff;
    const oldFTS = t.fts || 0;
    const oldIn = !!p.in;

    if(delta < 0 && oldFF <= 0) return;

    save(`${side} ${p.name} ff`, ()=>{
      p.ff = oldFF;
      t.fts = oldFTS;
      p.in = oldIn;
    });

    p.ff = oldFF + delta;
    t.fts = Math.max(0, oldFTS + delta);

    if(p.ff >= 5) p.in = false;

    clearMinus();
    render();
    return;
  }

  const old = p[s];
  save(`${side} ${p.name} ${s}`, ()=> p[s] = old);
  p[s] = old + delta;

  clearMinus();
  render();
}

function doShot(side, i, tKey, pts, ok){
  if(!can(side,i)) return;
  const p = getPlayers(side)[i];

  const snapShooter = JSON.stringify(p);
  const pmA = playersA.map(x=>x.pm||0);
  const pmB = playersB.map(x=>x.pm||0);

  save(`${side} ${p.name} ${tKey}`, ()=>{
    getPlayers(side)[i] = JSON.parse(snapShooter);
    playersA.forEach((x, idx)=> x.pm = pmA[idx] || 0);
    playersB.forEach((x, idx)=> x.pm = pmB[idx] || 0);
  });

  if(!minusMode){
    p[tKey].att++;
    if(ok){
      p[tKey].made++;
      p.pts += pts;
      applyPlusMinus(side, pts);
    }
    render();
    return;
  }

  if(p[tKey].att <= 0) return;

  if(ok){
    if(p[tKey].made <= 0) return;
    if(p.pts - pts < 0) return;
    p[tKey].made--;
    p.pts -= pts;
    applyPlusMinus(side, -pts);
  }
  p[tKey].att--;

  clearMinus();
  render();
}

function shot(side, i, tKey, pts){
  const p = getPlayers(side)[i];
  return `<div class="shot">
    <span>${p[tKey].made}/${p[tKey].att}</span>
    <button class="green" onclick="doShot('${side}',${i},'${tKey}',${pts},1)">+</button>
    <button class="red" onclick="doShot('${side}',${i},'${tKey}',${pts},0)">-</button>
  </div>`;
}

/* ===========================
   STATS SOLO PERIODO (Delta)
=========================== */
function deepCopy(obj){
  try{ return JSON.parse(JSON.stringify(obj)); }catch(e){ return obj; }
}
function periodKeyFromNumber(q){
  if(q <= 4) return `Q${q}`;
  return `OT${q-4}`;
}
function storePeriodSnapshot(endedQuarter){
  const q = (typeof endedQuarter === 'number' && endedQuarter > 0) ? endedQuarter : currentQuarter;
  const key = periodKeyFromNumber(q);
  // snapshot CUMULATIVO a fine periodo
  periodSnapshots[key] = {
    playersA: deepCopy(playersA),
    playersB: deepCopy(playersB)
  };
  // pulizia eventuali chiavi strane
  try{
    Object.keys(periodSnapshots).forEach(k=>{
      if(!/^Q[1-4]$/.test(k) && !/^OT\d+$/.test(k)) delete periodSnapshots[k];
    });
  }catch(e){}
  saveState();
}

function emptyPlayersLike(arr){
  return (arr||[]).map(p=>{
    return {
      name: p?.name || '',
      num: Number(p?.num||0),
      pts:0, ff:0, min:0, pm:0,
      '2pt':{made:0,att:0},
      '3pt':{made:0,att:0},
      tl:{made:0,att:0},
      fs:0, ra:0, rd:0, a:0, pp:0, pr:0, stf:0, sts:0,
      in:false, expelled:false
    };
  });
}
function diffPlayers(endArr, prevArr){
  const out = [];
  const a = Array.isArray(endArr) ? endArr : [];
  const b = Array.isArray(prevArr) ? prevArr : [];
  const n = Math.max(a.length, b.length);

  for(let i=0;i<n;i++){
    const e = a[i] || {};
    const p = b[i] || {};

    const dp = {
      name: e.name || p.name || '',
      num: Number(e.num ?? p.num ?? 0),
      pts: Math.max(0, (Number(e.pts)||0) - (Number(p.pts)||0)),
      ff:  Math.max(0, (Number(e.ff)||0)  - (Number(p.ff)||0)),
      min: Math.max(0, (Number(e.min)||0) - (Number(p.min)||0)),
      pm:  (Number(e.pm)||0)  - (Number(p.pm)||0),

      '2pt':{
        made: Math.max(0, (Number(e['2pt']?.made)||0) - (Number(p['2pt']?.made)||0)),
        att:  Math.max(0, (Number(e['2pt']?.att)||0)  - (Number(p['2pt']?.att)||0))
      },
      '3pt':{
        made: Math.max(0, (Number(e['3pt']?.made)||0) - (Number(p['3pt']?.made)||0)),
        att:  Math.max(0, (Number(e['3pt']?.att)||0)  - (Number(p['3pt']?.att)||0))
      },
      tl:{
        made: Math.max(0, (Number(e.tl?.made)||0) - (Number(p.tl?.made)||0)),
        att:  Math.max(0, (Number(e.tl?.att)||0)  - (Number(p.tl?.att)||0))
      },

      fs:  Math.max(0, (Number(e.fs)||0)  - (Number(p.fs)||0)),
      ra:  Math.max(0, (Number(e.ra)||0)  - (Number(p.ra)||0)),
      rd:  Math.max(0, (Number(e.rd)||0)  - (Number(p.rd)||0)),
      a:   Math.max(0, (Number(e.a)||0)   - (Number(p.a)||0)),
      pp:  Math.max(0, (Number(e.pp)||0)  - (Number(p.pp)||0)),
      pr:  Math.max(0, (Number(e.pr)||0)  - (Number(p.pr)||0)),
      stf: Math.max(0, (Number(e.stf)||0) - (Number(p.stf)||0)),
      sts: Math.max(0, (Number(e.sts)||0) - (Number(p.sts)||0)),
      in:false, expelled:false
    };
    out.push(dp);
  }
  return out;
}


/* ===========================
   MODALE STATS: scegli periodo (no prompt)
=========================== */
function askStatsPeriod(avail, defaultKey){
  return new Promise((resolve)=>{
    const ov = document.getElementById('periodPickOverlay');
    const sel = document.getElementById('periodPickSelect');
    const ok  = document.getElementById('periodPickOk');
    const cc  = document.getElementById('periodPickCancel');

    if(!ov || !sel || !ok || !cc){
      resolve(null);
      return;
    }

    let done = false;

    const cleanup = ()=>{
      document.removeEventListener('keydown', onKey);
      ok.removeEventListener('click', onOk);
      cc.removeEventListener('click', onCancel);
      ov.removeEventListener('click', onBackdrop);
    };

    const close = (val)=>{
      if(done) return;
      done = true;
      cleanup();
      ov.style.display = 'none';
      resolve(val);
    };

    const onOk = ()=> close(sel.value || null);
    const onCancel = ()=> close(null);
    const onBackdrop = (e)=>{ if(e.target === ov) close(null); };
    const onKey = (e)=>{
      if(e.key === 'Escape') close(null);
      if(e.key === 'Enter'){ e.preventDefault(); onOk(); }
    };

    sel.innerHTML = '';
    (avail || []).forEach(k=>{
      const opt = document.createElement('option');
      opt.value = k;
      opt.textContent = k;
      sel.appendChild(opt);
    });

    const pick = (defaultKey && avail.includes(defaultKey)) ? defaultKey : (avail[avail.length-1] || '');
    sel.value = pick;

    ov.style.display = 'flex';
    setTimeout(()=>{ try{ sel.focus(); }catch(e){} }, 0);

    ok.addEventListener('click', onOk);
    cc.addEventListener('click', onCancel);
    ov.addEventListener('click', onBackdrop);
    document.addEventListener('keydown', onKey);
  });
}

function listAvailablePeriods(){

  const keys = Object.keys(periodSnapshots || {});
  const sorter = (k)=>{
    if(/^Q[1-4]$/.test(k)) return 100 + Number(k.slice(1));
    if(/^OT\d+$/.test(k)) return 200 + Number(k.slice(2));
    return 9999;
  };
  return keys.sort((x,y)=> sorter(x)-sorter(y));
}

function normalizePeriodInput(raw){
  const s = String(raw||'').trim().toUpperCase().replaceAll(' ','');
  if(!s) return null;
  if(/^Q[1-4]$/.test(s)) return s;
  if(/^[1-4]$/.test(s)) return `Q${s}`;
  const m = s.match(/^OT(\d+)$/);
  if(m) return `OT${Number(m[1])}`;
  return null;
}

function prevPeriodKey(key){
  if(!key) return null;
  if(/^Q[2-4]$/.test(key)) return `Q${Number(key.slice(1))-1}`;
  if(key === 'Q1') return null;
  if(/^OT\d+$/.test(key)){
    const n = Number(key.slice(2));
    if(n <= 1) return 'Q4';
    return `OT${n-1}`;
  }
  return null;
}

async function showQuarterStats(){
  const avail = listAvailablePeriods();
  if(!avail.length){
    alert('Nessun periodo salvato ancora.\n\nNota: i delta vengono memorizzati automaticamente a fine periodo (quando il tempo arriva a 0 o quando passi periodo).');
    return;
  }

  const hint = avail.join(', ');
  const picked = await askStatsPeriod(avail, avail[avail.length-1]);
  if(picked === null) return;

  const keyRaw = String(picked||'').trim().toUpperCase();
  const key = normalizePeriodInput(keyRaw) || ((/^Q[1-4]$/.test(keyRaw) || /^OT\d+$/.test(keyRaw)) ? keyRaw : null);
  if(!key){
    alert('Periodo non valido. Usa Q1..Q4 oppure OT1, OT2...');
    return;
  }
  const snapEnd = periodSnapshots?.[key];
  if(!snapEnd){
    alert(`Non ho lo snapshot per ${key}. Disponibili: ${hint}`);
    return;
  }
  const prevKey = prevPeriodKey(key);
  const snapPrev = prevKey ? periodSnapshots?.[prevKey] : null;

  const endA = snapEnd.playersA;
  const endB = snapEnd.playersB;
  const prevA = snapPrev?.playersA || emptyPlayersLike(endA);
  const prevB = snapPrev?.playersB || emptyPlayersLike(endB);

  statsView = {
    mode:'period',
    label:key,
    A: diffPlayers(endA, prevA),
    B: diffPlayers(endB, prevB)
  };

  try{ renderStats(); }catch(e){ console.error(e); }
}

function showTotalStats(){
  statsView = { mode:'total', label:null, A:null, B:null };
  try{ renderStats(); }catch(e){ console.error(e); }
}

/* ===========================
   QUARTO / OT
=========================== */
function finalizePeriodAndAdvance(){
  // Salva parziale del periodo corrente (Q1..Q4 / OT) e prepara il prossimo periodo
  const a = Number(scoreA.textContent) - lastScoreA;
  const b = Number(scoreB.textContent) - lastScoreB;

  if(currentQuarter <= 4){
    document.getElementById(`q${currentQuarter}a`).textContent = a;
    document.getElementById(`q${currentQuarter}b`).textContent = b;
  } else {
    const otIndex = currentQuarter - 4;
    ensureOtRow(otIndex);
    document.getElementById(`ot${otIndex}a`).textContent = a;
    document.getElementById(`ot${otIndex}b`).textContent = b;
  }

  lastScoreA += a;
  lastScoreB += b;

  // memorizza snapshot cumulativo di fine periodo (per vedere le stats 'solo quarto')
  try{ storePeriodSnapshot(currentQuarter); }catch(e){}

  // Fine partita: se termina Q4 o un OT e NON c'√® parit√†, chiudi la partita.
  if(currentQuarter >= 4 && lastScoreA !== lastScoreB){
    gameClosed = true;
    sec = 0;
    // reset stats di squadra per coerenza
    teamA.to = 0; teamB.to = 0;
    teamA.fts = 0; teamB.fts = 0;
    undoInfo.textContent = '‚úÖ Fine partita';
    updateSideWidth();
    return;
  }

  // reset stats di squadra per periodo
  teamA.to = 0;
  teamB.to = 0;
  teamA.fts = 0;
  teamB.fts = 0;

  // avanza periodo e ricarica cronometro
  currentQuarter += 1;
  sec = (currentQuarter <= 4) ? QUARTER_LEN : OT_LEN;
}

/* ===========================
   AUTOSAVE SNAPSHOT (CLICK SU ‚ÄúPeriodo‚Äù)
   - salva un JSON con lo stato COMPLETO, dopo aver scritto i parziali del periodo chiuso
   - NON cambia il flusso: periodo e cronometro avanzano come sempre
=========================== */
function autoSavePeriodSnapshot(endedQuarter){
  const gameId = ensureGameId();
  try{ saveState(); }catch(e){}

  const q = (typeof endedQuarter === 'number' && endedQuarter > 0) ? endedQuarter : currentQuarter;
  const label = (q <= 4) ? `Q${q}` : `OT${q-4}`;

  // nome base file (come saveGame)
  const aName = (nameA.value || 'Squadra A').trim();
  const bName = (nameB.value || 'Squadra B').trim();
  const date  = (dataGara.value || '').trim();

  const baseName = `${aName} vs ${bName}${date ? ' ' + date : ''} ‚Ä¢ ${label}`;

  // snapshot stato (include quarters dal DOM: Q1..Q4/OT)
  const state = snapshotState();

  // score attuale (dopo finalize)
  const scA = document.getElementById('scoreA')?.textContent ?? '0';
  const scB = document.getElementById('scoreB')?.textContent ?? '0';

  const payload = {
    __type: 'basket_stats_snapshot',
    __version: 1,
    meta: {
      gameId: gameId,
      snapshot: label,
      name: baseName,
      period: label,
      date: date || '',
      aName, bName,
      scoreA: String(scA),
      scoreB: String(scB),
      score: `${scA}-${scB}`,
      savedAt: new Date().toISOString()
    },
    state
  };
  // Salva nello store per il FILE UNICO (niente download per quarto)
  SNAPSHOT_STORE.gameId = gameId;
  SNAPSHOT_STORE.baseMeta = (getMetaFromUI?getMetaFromUI(): (SNAPSHOT_STORE.baseMeta||{}));
  SNAPSHOT_STORE.snaps[label] = payload;

  undoInfo.textContent = 'Autosave memorizzato: ' + label;
  updateSideWidth();
}


function nextQuarter(){
  // manuale (tap su "Periodo") solo a cronometro fermo e a 0
  if(timer || sec!==0) return;
  if(gameClosed) return;

  const endedQ = currentQuarter; // periodo che stai chiudendo
  finalizePeriodAndAdvance();    // qui scrive il parziale e prepara il prossimo periodo

  // autosave DOPO la finalize: cos√¨ Q1 finisce nel file Q1 (non nel Q2)
  try{ autoSavePeriodSnapshot(endedQ); }catch(e){}

  render();
}

/* ===========================
   CLOCK
=========================== */
function startClock(){
  // Avvio robusto per WebView/.exe: niente dipendenza da setInterval "puro"
  if(timer) return;
  if(gameClosed){
    alert('Partita terminata.');
    return;
  }

  // anti-sleep + audio (serve gesto utente)
  requestWakeLock();
  ensureAudio();

  let last = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  let carry = 0;

  const step = ()=>{
    if(!timer) return; // stop richiesto
    const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    let dt = now - last;
    if(!Number.isFinite(dt) || dt < 0) dt = 0;
    last = now;

    carry += dt;

    // Consuma i secondi accumulati (se il WebView "pausa" e poi riprende, recupera)
    let n = Math.floor(carry / 1000);
    if(n > 0){
      carry -= n * 1000;

      while(n-- > 0){
        if(sec<=0){
          sec = 0;
          stopClock();
          render();
          return;
        }

        sec--;

        if(sec <= 0){
          sec = 0;
          beep();
          stopClock();
          finalizePeriodAndAdvance();
          render();
          return;
        }

        playersA.forEach(p=>{ if(p.in) p.min += 1; });
        playersB.forEach(p=>{ if(p.in) p.min += 1; });
      }
      render();
    }

    // Tick frequente ma leggero; quando la finestra √® attiva, √® molto stabile
    timer = setTimeout(step, 150);
  };

  timer = setTimeout(step, 0);
}

function stopClock(){
  if(timer){
    clearTimeout(timer);
    timer = null;
  }
  releaseWakeLock();
  saveState();
  updateSideWidth();
}

function nudgeClock(deltaSec){
  deltaSec = Math.trunc(Number(deltaSec) || 0);
  if(deltaSec === 0) return;

  const periodLen = (currentQuarter <= 4) ? QUARTER_LEN : OT_LEN;

  if(deltaSec > 0){
    const actual = Math.min(deltaSec, sec);
    if(actual <= 0) return;

    const oldSec = sec;
    const minsA = playersA.map(p=>p.min||0);
    const minsB = playersB.map(p=>p.min||0);

    save(`Tempo +${actual}s`, ()=>{
      sec = oldSec;
      playersA.forEach((p,i)=> p.min = minsA[i] || 0);
      playersB.forEach((p,i)=> p.min = minsB[i] || 0);
    });

    sec -= actual;
    playersA.forEach(p=>{ if(p.in) p.min += actual; });
    playersB.forEach(p=>{ if(p.in) p.min += actual; });

    render();
    return;
  }

  const reqBack = Math.abs(deltaSec);
  const maxByClock = Math.max(0, periodLen - sec);

  const inMins = [];
  playersA.forEach(p=>{ if(p.in) inMins.push(p.min||0); });
  playersB.forEach(p=>{ if(p.in) inMins.push(p.min||0); });

  const maxByPlayers = inMins.length ? Math.min(...inMins) : maxByClock;
  const actual = Math.min(reqBack, maxByClock, maxByPlayers);
  if(actual <= 0) return;

  const oldSec = sec;
  const minsA = playersA.map(p=>p.min||0);
  const minsB = playersB.map(p=>p.min||0);

  save(`Tempo -${actual}s`, ()=>{
    sec = oldSec;
    playersA.forEach((p,i)=> p.min = minsA[i] || 0);
    playersB.forEach((p,i)=> p.min = minsB[i] || 0);
  });

  sec += actual;
  playersA.forEach(p=>{ if(p.in) p.min = Math.max(0, (p.min||0) - actual); });
  playersB.forEach(p=>{ if(p.in) p.min = Math.max(0, (p.min||0) - actual); });

  render();
}

/* ===========================
   RENDER
=========================== */
function renderTeamTable(side, tbodyId){
  const arr = getPlayers(side);
  const tb = document.getElementById(tbodyId);
  tb.innerHTML = '';

  arr.forEach((p,i)=>{
    if(isLocked(p) && p.in) p.in = false;

    let ffClass = '';
    if (p.ff >= 5) ffClass = 'ff-danger';
    else if (p.ff === 4) ffClass = 'ff-warning';

    const inRowClass = p.in ? 'in-row' : '';

    const locked = isLocked(p);
    const ioClass = locked ? 'foul-out' : (p.in ? 'in' : 'out');
    const ioLabel = locked ? 'OUT' : (p.in ? 'IN' : 'OUT');

    tb.innerHTML += `
<tr class="${inRowClass}">
  <td>
    <input class="player-num-input" type="number" min="0" max="99"
      value="${escAttr(p.num)}"
      oninput="setPlayerNum('${side}', ${i}, this.value)"
    />
  </td>
  <td class="name">
    <input class="player-name-input"
      value="${escAttr(p.name)}"
      oninput="setPlayerName('${side}', ${i}, this.value)"
    />
    <span class="status-wrap">
      <button class="${ioClass} io-btn" ${locked ? 'disabled' : ''} onclick="${locked ? '' : `toggleIn('${side}', ${i})`}">${ioLabel}</button>
      <button class="esp-btn" ${locked ? 'disabled' : ''} data-side="${side}" data-idx="${i}" title="Tieni premuto per ESP (700ms)">ESP</button>
    </span>
  </td>
  <td>${p.pts}</td>
  <td>
    <span class="${ffClass}">${p.ff}</span>
    <button class="red" onclick="addStat('${side}',${i},'ff',1)">+</button>
  </td>
  <td>${formatTime(p.min)}</td>
  <td>${pointsPerMinute(p)}</td>
  <td>${shot(side,i,'2pt',2)}</td>
  <td>${shot(side,i,'3pt',3)}</td>
  <td>${shot(side,i,'tl',1)}</td>
  ${['fs','ra','rd','a','pp','pr','stf','sts']
    .map(s=>`<td><button class="blue" onclick="addStat('${side}',${i},'${s}',1)">${p[s]}</button></td>`)
    .join('')}
</tr>`;
  });
}

function sumTeam(arr, side){
  let pts=0;
  arr.forEach(p=>{ pts += (p.pts||0); });
  if(side==='A' || side==='B'){
    pts += (scoreAdj?.[side] || 0);
  }
  return {pts};
}

function render(){
  renderTeamTable('A', 'tbodyA');
  renderTeamTable('B', 'tbodyB');

  const a = sumTeam(playersA,'A');
  const b = sumTeam(playersB,'B');

  scoreA.textContent = a.pts;
  scoreB.textContent = b.pts;

  teamFoulsA.textContent = teamA.fts || 0;
  teamFoulsB.textContent = teamB.fts || 0;

  teamFoulsA.classList.toggle('team-fouls-danger', (teamA.fts||0) >= 4);
  teamFoulsB.classList.toggle('team-fouls-danger', (teamB.fts||0) >= 4);

  sectionTitleA.textContent = (nameA.value || 'Squadra A');
  sectionTitleB.textContent = (nameB.value || 'Squadra B');

  teamAPP.textContent = teamA.pp;
  teamAPR.textContent = teamA.pr;
  teamATO.textContent = teamA.to;
  teamATOMax.textContent = maxTimeouts();

  teamAFTS.textContent = teamA.fts || 0;
  teamAFTS.classList.toggle('fts-danger', (teamA.fts || 0) >= 4);
teamBPP.textContent = teamB.pp;
  teamBPR.textContent = teamB.pr;
  teamBTO.textContent = teamB.to;
  teamBTOMax.textContent = maxTimeouts();

  teamBFTS.textContent = teamB.fts || 0;
  teamBFTS.classList.toggle('fts-danger', (teamB.fts || 0) >= 4);

  clock.textContent = formatTime(sec);
  qNum.textContent = gameClosed ? 'FINE' : periodLabel(currentQuarter);

  saveState();
  updateSideWidth();

  if(document.getElementById('statsOverlay').style.display === 'block'){
    renderStats();
  }
  if(document.getElementById('gamesOverlay').style.display === 'block'){
    renderLibrary();
  }
}

/* ===========================
   LONG-PRESS ESP
=========================== */
const ESP_HOLD_MS = 700;
let holdTimer = null;
let holdBtn = null;
let holdSide = null;
let holdIdx = null;

function holdStart(btn){
  if(!btn || btn.disabled) return;
  holdCancel();

  holdBtn = btn;
  holdSide = btn.getAttribute('data-side');
  holdIdx  = Number(btn.getAttribute('data-idx'));

  holdBtn.classList.add('holding');

  holdTimer = setTimeout(()=>{
    expelPlayer(holdSide, holdIdx);
    holdCancel();
  }, ESP_HOLD_MS);
}

function holdCancel(){
  if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
  if(holdBtn){ holdBtn.classList.remove('holding'); }
  holdBtn = null; holdSide = null; holdIdx = null;
}

document.addEventListener('touchstart', (e)=>{
  const btn = e.target.closest?.('.esp-btn');
  if(!btn) return;
  e.preventDefault();
  holdStart(btn);
}, {passive:false});

document.addEventListener('touchend', (e)=>{
  const btn = e.target.closest?.('.esp-btn');
  if(btn) e.preventDefault();
  holdCancel();
}, {passive:false});
document.addEventListener('touchcancel', holdCancel, {passive:true});

document.addEventListener('mousedown', (e)=>{
  const btn = e.target.closest?.('.esp-btn');
  if(!btn) return;
  e.preventDefault();
  holdStart(btn);
});
document.addEventListener('mouseup', holdCancel);
document.addEventListener('mouseleave', holdCancel);
document.addEventListener('scroll', holdCancel, true);

/* === FIX STATS: overlay sempre visibile + render protetto === */
function showStatsError(err){
  try{
    const body = $id('statsBody');
    if(body){
      body.innerHTML = `<div style="padding:12px; font-family:monospace; color:#c0392b; font-weight:bold;">
        ERRORE STATS:<br>${escHtml(err?.stack || err)}
      </div>`;
    }
  }catch(e){}
}

function openStats(){
  const ov = $id('statsOverlay');
  const body = $id('statsBody');
  ov.style.display = 'block';
  if(body){
    body.innerHTML = '<div style="padding:12px; color:#7f8c8d; font-weight:bold;">Caricamento statistiche‚Ä¶</div>';
  }
  // lascia respirare il repaint, poi renderizza
  setTimeout(()=>{
    try{
      renderStats();
    }catch(e){
      showStatsError(e);
    }
  }, 0);
}

function closeStats(){
  $id('statsOverlay').style.display = 'none';
}

/* ===========================
   STATISTICHE (PIR/OER/+/-)
=========================== */
function calcPIR(p){
  /*
    PIR ‚Äústile FIBA‚Äù adattato ai dati disponibili (giovanili/minibasket friendly)
    Formula base: (positivi) - (negativi)

    Positivi:
      PTS + REB (RA+RD) + A + PR + STf + FS
    Negativi:
      tiri sbagliati (FGA-FGM) + liberi sbagliati (FTA-FTM) + PP + FF + STs

    Nota:
      - qui uso FGA = 2PT att + 3PT att, FGM = 2PT made + 3PT made
      - STf/STs: nel tuo file sono gi√† usati come ‚Äústoppate fatte/subite‚Äù (o simili)
  */
  const fgm = (p['2pt']?.made||0) + (p['3pt']?.made||0);
  const fga = (p['2pt']?.att||0)  + (p['3pt']?.att||0);
  const ftm = (p.tl?.made||0);
  const fta = (p.tl?.att||0);

  const missedFG = Math.max(0, fga - fgm);
  const missedFT = Math.max(0, fta - ftm);

  const reb = (p.ra||0) + (p.rd||0);

  return (p.pts||0)
    + reb
    + (p.a||0)
    + (p.pr||0)
    + (p.stf||0)
    + (p.fs||0)
    - missedFG
    - missedFT
    - (p.pp||0)
    - (p.ff||0)
    - (p.sts||0);
}
function calcOER(p){
  /*
    OER = punti per 100 possessi stimati.
    Possessi stimati ‚âà FGA - ORB + TO + 0.44*FTA
    (stima ‚Äústandard‚Äù; sui giovanili evita di impazzire su dati incompleti)

    Per rendere pi√π stabile su campioni piccoli:
      - se i possessi stimati sono < 3 ritorno 0
        (evita numeri ‚Äúsparati‚Äù con poche azioni)
  */
  const fga = (p['2pt']?.att||0) + (p['3pt']?.att||0);
  const fta = (p.tl?.att||0);
  const to  = (p.pp||0);
  const orb = (p.ra||0); // RA = rimbalzi in attacco

  const denom = fga - orb + 0.44*fta + to;

  if(denom < 3) return 0;
  return (100 * (p.pts||0) / denom);
}
function overlayClickClose(){ closeStats(); }
function fmtOER(x){ return Number.isFinite(x) ? x.toFixed(1) : '0.0'; }
function fmtPM(v){ const n = Number(v||0); return n>0 ? `+${n}` : `${n}`; }
function pmClass(v){
  const n = Number(v||0);
  if(n > 0) return 'pm-pos';
  if(n < 0) return 'pm-neg';
  return '';
}

function updateStatsMeta(){
  // Score line centrale
  const aName = (nameA?.value || 'Squadra A').trim();
  const bName = (nameB?.value || 'Squadra B').trim();
  const scA = $id('scoreA')?.textContent ?? '0';
  const scB = $id('scoreB')?.textContent ?? '0';
  let scoreLine = `${aName}  ${scA} - ${scB}  ${bName}`;
  if(statsView?.mode === 'period' && statsView.label){ scoreLine += `   ‚Ä¢   SOLO ${statsView.label}`; }
  const scoreEl = $id('statsScoreLine');
  if(scoreEl) scoreEl.textContent = scoreLine;

  // Meta compatta su UNA riga
  const camp = (campionato?.value || '').trim();
  const gir  = (girone?.value || '').trim();
  const date = (dataGara?.value || '').trim();
  const g    = (giornata?.value || '').trim();
  const ar   = ((andataRitorno?.value || '').trim().toUpperCase());
  const cf   = ((casaFuori?.value || '').trim().toUpperCase());
  const arb1 = (arbitro1?.value || '').trim();
  const arb2 = (arbitro2?.value || '').trim();

  const infoText = [
    camp ? `Cat: ${camp}` : null,
    gir  ? `Gir: ${gir}`  : null,
    date ? `Data: ${date}`: null,
    g    ? `Giornata: ${g}` : null,
    ar   ? `A/R: ${ar}`   : null,
    cf   ? `C/F: ${cf}`   : null,
    arb1 ? `Arb1: ${arb1}`: null,
    arb2 ? `Arb2: ${arb2}`: null,
  ].filter(Boolean).join('   ‚Ä¢   ') || '‚Äî';

  $id('statsMetaInfo').textContent = infoText;

  // Parziali compatti:  a-b / a-b / a-b / a-b  (OT se presenti)
  // Nota: per i progressivi NON dimostrare valori ‚Äúcopiati‚Äù sui quarti non ancora giocati.
  // Se un quarto non √® stato ancora inserito (cell '‚Äî' o vuota), nei progressivi mostriamo '‚Äî'.
  const toNum = (v)=>{
    const s = String(v ?? '').trim();
    const n = parseInt(s, 10);
    return Number.isFinite(n) ? n : 0;
  };
  const getQObj = (n, side)=>{
    const raw = String($id(`q${n}${side}`)?.textContent ?? '‚Äî').trim();
    const played = (raw !== '‚Äî' && raw !== '');
    return { raw, n: toNum(raw), played };
  };

  const splits = []; // [{a,b,played,label}]
  // Q1..Q4
  for(let q=1;q<=4;q++){
    const A = getQObj(q,'a');
    const B = getQObj(q,'b');
    const played = A.played || B.played;
    splits.push({ label:`Q${q}`, a:A.n, b:B.n, played });
  }

  // OT dinamici (OT1, OT2, ...)
  const otHost = $id('otRows');
  if(otHost){
    const rows = [...otHost.querySelectorAll('div.qrow')];
    rows.forEach(r=>{
      const label = (r.querySelector('strong')?.textContent || '').trim(); // OT1
      if(!label) return;
      const spans = r.querySelectorAll('span');
      const rawA = String(spans[0]?.textContent ?? '‚Äî').trim();
      const rawB = String(spans[1]?.textContent ?? '‚Äî').trim();
      const a = toNum(rawA);
      const b = toNum(rawB);
      const played = ((rawA !== '‚Äî' && rawA !== '') || (rawB !== '‚Äî' && rawB !== ''));
      // includi solo OT compilati (almeno uno non zero o comunque inserito)
      if(played && (a!==0 || b!==0)) {
        splits.push({ label, a, b, played:true });
      }
    });
  }

  const fmtPair = (a,b)=> `${a}-${b}`;

  // Parziali: se non giocato mostriamo 0-0 (come richiesto)
  const parziali = splits.map(s=> fmtPair(s.a, s.b)).join(' / ');

  // Progressivi: mostra solo fino all'ultimo quarto/OT effettivamente inserito
  let ca=0, cb=0;
  const prog = splits.map(s=>{
    if(!s.played) return '‚Äî';
    ca += s.a; cb += s.b;
    return fmtPair(ca, cb);
  }).join(' / ');
  const quartersHTML = `
    <div class="meta-splits"><span class="lbl">Parziali:</span><span class="vals">${escHtml(parziali)}</span></div>
    <div class="meta-splits"><span class="lbl">Progressivi:</span><span class="vals">${escHtml(prog)}</span></div>
  `;
  $id('statsMetaQuarters').innerHTML = quartersHTML;
}


function teamTotals(arr){
  const t = {
    pts:0, ff:0, min:0,
    '2pt':{made:0,att:0},
    '3pt':{made:0,att:0},
    tl:{made:0,att:0},
    fs:0,ra:0,rd:0,a:0,pp:0,pr:0,stf:0,sts:0,
    pm:0
  };
  arr.forEach(p=>{
    t.pts += (p.pts||0);
    t.ff += (p.ff||0);
    t.min += (p.min||0);
    t['2pt'].made += (p['2pt']?.made||0);
    t['2pt'].att  += (p['2pt']?.att||0);
    t['3pt'].made += (p['3pt']?.made||0);
    t['3pt'].att  += (p['3pt']?.att||0);
    t.tl.made += (p.tl?.made||0);
    t.tl.att  += (p.tl?.att||0);
    ['fs','ra','rd','a','pp','pr','stf','sts'].forEach(k=> t[k] += (p[k]||0));
    t.pm += (p.pm||0);
  });
  return t;
}

function renderStatsTeam(side, title, arr){
  const view = sortForStats(side, arr);

  const totals = teamTotals(arr);
  const oerTot = calcOER(totals);
  const pirTot = arr.reduce((sum,p)=> sum + calcPIR(p), 0);

  const head = `
    <div class="stats-block">
      <h3>${escAttr(title)}</h3>
      <div class="stats-meta-block" style="margin:2px 0 8px; color:#7f8c8d; font-weight:bold;">
        ${renderSplitsLine(side)}
      </div>
      <table class="stats-table">
        <thead>
          <tr>
            <th style="width:38px; cursor:pointer;" data-side="${side}" data-stats-key="num">#</th>
            <th style="width:180px; cursor:pointer;" data-side="${side}" data-stats-key="name">Atleta</th>
            <th style="cursor:pointer;" data-side="${side}" data-stats-key="pts">PTS</th>
            <th style="cursor:pointer;" data-side="${side}" data-stats-key="ff">FF</th>
            <th style="cursor:pointer;" data-side="${side}" data-stats-key="min">MIN</th>
            <th style="cursor:pointer;" data-side="${side}" data-stats-key="pmr">P/M</th>
            <th style="cursor:pointer;" data-side="${side}" data-stats-key="t2">2PT</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="t2p">T2 %</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="t3">3PT</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="t3p">T3 %</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="tl">TL</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="tlp">TL %</th>
            <th style="cursor:pointer;" data-side="${side}" data-stats-key="fs">FS</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="ra">RA</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="rd">RD</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="a">A</th>
            <th style="cursor:pointer;" data-side="${side}" data-stats-key="pp">PP</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="pr">PR</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="stf">STf</th><th style="cursor:pointer;" data-side="${side}" data-stats-key="sts">STs</th>
            <th class="pir-col" style="cursor:pointer;" data-side="${side}" data-stats-key="pir">PIR</th>
            <th style="cursor:pointer;" data-side="${side}" data-stats-key="oer">OER</th>
            <th style="cursor:pointer;" data-side="${side}" data-stats-key="pm">+/-</th>
          </tr>
        </thead>
        <tbody>
  `;

  const rows = view.map(p=>{
    const pir = calcPIR(p);
    const oer = calcOER(p);
    const pm  = p.pm||0;
    return `
      <tr>
        <td>${p.num ?? ''}</td>
        <td class="name">${escAttr(p.name)}</td>
        <td>${p.pts||0}</td>
        <td>${p.ff||0}</td>
        <td>${formatTime(p.min||0)}</td>
        <td>${statsPM(p)}</td>
        <td>${(p['2pt']?.made||0)}/${(p['2pt']?.att||0)}</td>
        <td>${pct(p['2pt']?.made||0, p['2pt']?.att||0)}</td>
        <td>${(p['3pt']?.made||0)}/${(p['3pt']?.att||0)}</td>
        <td>${pct(p['3pt']?.made||0, p['3pt']?.att||0)}</td>
        <td>${(p.tl?.made||0)}/${(p.tl?.att||0)}</td>
        <td>${pct(p.tl?.made||0, p.tl?.att||0)}</td>
        <td>${p.fs||0}</td>
        <td>${p.ra||0}</td>
        <td>${p.rd||0}</td>
        <td>${p.a||0}</td>
        <td>${p.pp||0}</td>
        <td>${p.pr||0}</td>
        <td>${p.stf||0}</td>
        <td>${p.sts||0}</td>
        <td class="pir-col">${pir}</td>
        <td>${fmtOER(oer)}</td>
        <td class="${pmClass(pm)}">${fmtPM(pm)}</td>
      </tr>
    `;
  }).join('');

  const foot = `
        </tbody>
        <tfoot>
          <tr>
            <td colspan="2">TOT</td>
            <td>${totals.pts}</td>
            <td>${totals.ff}</td>
            <td>${formatTime(totals.min)}</td>
            <td>${statsPM(totals)}</td>
            <td>${totals['2pt'].made}/${totals['2pt'].att}</td>
            <td>${pct(totals['2pt'].made, totals['2pt'].att)}</td>
            <td>${totals['3pt'].made}/${totals['3pt'].att}</td>
            <td>${pct(totals['3pt'].made, totals['3pt'].att)}</td>
            <td>${totals.tl.made}/${totals.tl.att}</td>
            <td>${pct(totals.tl.made, totals.tl.att)}</td>
            <td>${totals.fs}</td>
            <td>${totals.ra}</td>
            <td>${totals.rd}</td>
            <td>${totals.a}</td>
            <td>${totals.pp}</td>
            <td>${totals.pr}</td>
            <td>${totals.stf}</td>
            <td>${totals.sts}</td>
            <td class="pir-col">${pirTot}</td>
            <td>${fmtOER(oerTot)}</td>
            <td class="${pmClass(totals.pm)}">${fmtPM(totals.pm)}</td>
          </tr>
        </tfoot>
      </table>
    </div>
  `;
  return head + rows + foot;
}


function renderStats(){
  const aName = (nameA.value || 'Squadra A');
  const bName = (nameB.value || 'Squadra B');

  const arrA = (statsView?.mode === 'period' && Array.isArray(statsView.A)) ? statsView.A : playersA;
  const arrB = (statsView?.mode === 'period' && Array.isArray(statsView.B)) ? statsView.B : playersB;

  $id('statsBody').innerHTML = renderStatsTeam('A', aName, arrA) + renderStatsTeam('B', bName, arrB);
  updateStatsMeta();
}

/* ===== EXPORT CSV ===== */
function downloadBlob(filename, blob){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function csvCell(v){
  const s = String(v ?? '');
  if (s.includes(';') || s.includes('"') || s.includes('\\n') || s.includes('\\r')) {
    return `"${s.replaceAll('"','""')}"`;
  }
  return s;
}
function buildStatsMetaLines(){
  const aN = (nameA.value || 'Squadra A').trim();
  const bN = (nameB.value || 'Squadra B').trim();

  const scoreA = document.getElementById('scoreA')?.textContent ?? '0';
  const scoreB = document.getElementById('scoreB')?.textContent ?? '0';
  const periodo = document.getElementById('qNum')?.textContent ?? String(currentQuarter||1);

  const extra = [
    ['CATEGORIA', (campionato.value||'').trim()],
    ['GIRONE', (girone.value||'').trim()],
    ['DATA', (dataGara.value||'').trim()],
    ['GIORNATA', (giornata.value||'').trim()],
    ['A/R', (andataRitorno.value||'').trim()],
    ['CASA/FUORI', (casaFuori.value||'').trim()],
    ['ARBITRO 1', (arbitro1.value||'').trim()],
    ['ARBITRO 2', (arbitro2.value||'').trim()],
  ];

  const lines = [];
  lines.push([`${aN} vs ${bN}`].map(csvCell).join(';'));
  lines.push(['RISULTATO', `${scoreA}-${scoreB}`].map(csvCell).join(';'));
  lines.push(['PERIODO', `Q${periodo}`].map(csvCell).join(';'));

  extra.forEach(([k,v])=>{ if(v) lines.push([k, v].map(csvCell).join(';')); });

  // Parziali (Q/OT)
  const sa = getPeriodSplits('A').filter(x=> (x.val ?? '‚Äî') !== '‚Äî').map(x=>`${x.label}:${x.val}`).join(' ‚Ä¢ ');
  const sb = getPeriodSplits('B').filter(x=> (x.val ?? '‚Äî') !== '‚Äî').map(x=>`${x.label}:${x.val}`).join(' ‚Ä¢ ');
  if(sa) lines.push(['PARZIALI A', sa].map(csvCell).join(';'));
  if(sb) lines.push(['PARZIALI B', sb].map(csvCell).join(';'));

  lines.push('');
  return lines.join('\n');
}

function statsRowsForCSV(teamName, arr){
  const sorted = Array.isArray(arr) ? [...arr].sort((a,b)=> (Number(a.num||0) - Number(b.num||0))) : [];

  const header = ['#','Atleta','PTS','FF','MIN','P/M','2PT','3PT','TL','FS','RA','RD','A','PP','PR','STf','STs','PIR','OER','+/-'];
  const lines = [];
  lines.push([teamName].map(csvCell).join(';'));
  lines.push(header.map(csvCell).join(';'));

  arr.forEach(p=>{
    const row = [
      p.num ?? '', p.name ?? '', p.pts||0, p.ff||0, formatTime(p.min||0),
      statsPM(p),
      `${(p['2pt']?.made||0)}/${(p['2pt']?.att||0)}`,
      `${(p['3pt']?.made||0)}/${(p['3pt']?.att||0)}`,
      `${(p.tl?.made||0)}/${(p.tl?.att||0)}`,
      p.fs||0, p.ra||0, p.rd||0, p.a||0, p.pp||0, p.pr||0, p.stf||0, p.sts||0,
      calcPIR(p), fmtOER(calcOER(p)), fmtPM(p.pm||0),
    ];
    lines.push(row.map(csvCell).join(';'));
  });

  const totals = teamTotals(arr);
  const oerTot = fmtOER(calcOER(totals));
  const pirTot = arr.reduce((sum,p)=> sum + calcPIR(p), 0);

  const totRow = [
    '', 'TOT',
    totals.pts, totals.ff, formatTime(totals.min),
    statsPM(totals),
    `${totals['2pt'].made}/${totals['2pt'].att}`,
    `${totals['3pt'].made}/${totals['3pt'].att}`,
    `${totals.tl.made}/${totals.tl.att}`,
    totals.fs, totals.ra, totals.rd, totals.a, totals.pp, totals.pr, totals.stf, totals.sts,
    pirTot, oerTot, fmtPM(totals.pm||0),
  ];
  lines.push(totRow.map(csvCell).join(';'));
  lines.push('');
  return lines.join('\\n');
}
function exportStatsExcel(){
  // Export Excel ‚Äúvero‚Äù (.xlsx) tramite SheetJS (XLSX)
  // Nota: il file viene creato localmente nel browser, come il PDF.
  if(typeof XLSX === 'undefined'){
    alert('Libreria Excel non caricata (XLSX). Controlla la connessione o ricarica la pagina.');
    return;
  }

  const aName = (nameA.value || 'Squadra A').trim();
  const bName = (nameB.value || 'Squadra B').trim();
  const date = (dataGara.value || '').trim();

  const scoreA = document.getElementById('scoreA')?.textContent ?? '0';
  const scoreB = document.getElementById('scoreB')?.textContent ?? '0';
  const periodo = document.getElementById('qNum')?.textContent ?? String(currentQuarter||1);

  const camp = (campionato.value || '').trim() || '';
  const gir  = (girone.value || '').trim() || '';
  const gior = (giornata.value || '').trim() || '';
  const ar   = ((andataRitorno.value || '').trim().toUpperCase()) || '';
  const cf   = ((casaFuori.value || '').trim().toUpperCase()) || '';
  const arb1 = (arbitro1.value || '').trim() || '';
  const arb2 = (arbitro2.value || '').trim() || '';

  // Parziali Q/OT
  const qLineBase = `${q1a.textContent}-${q1b.textContent} / ${q2a.textContent}-${q2b.textContent} / ${q3a.textContent}-${q3b.textContent} / ${q4a.textContent}-${q4b.textContent}`;
  const otHost = document.getElementById('otRows');
  const otParts = [];
  if(otHost){
    const rows = otHost.querySelectorAll('.qrow');
    rows.forEach((r)=>{
      const strong = r.querySelector('strong')?.textContent || '';
      const spans = r.querySelectorAll('span');
      const a = spans[0]?.textContent ?? '‚Äî';
      const b = spans[1]?.textContent ?? '‚Äî';
      if(strong) otParts.push(`${a}-${b}`);
    });
  }
  const qLine = qLineBase + (otParts.length ? (' / ' + otParts.join(' / ')) : '');

  // Meta (riga 1) stile ‚Äúscreen‚Äù
  const infoText = [
    camp !== '‚Äî' ? `Cat: ${camp}` : null,
    gir  !== '‚Äî' ? `Gir: ${gir}` : null,
    data !== '‚Äî' ? `Data: ${data}`: null,
    gior !== '‚Äî' ? `Giornata: ${gior}` : null,
    ar   !== '‚Äî' ? `A/R: ${ar}`   : null,
    cf   !== '‚Äî' ? `C/F: ${cf}`   : null,
    arb1 !== '‚Äî' ? `Arb1: ${arb1}`: null,
    arb2 !== '‚Äî' ? `Arb2: ${arb2}`: null,
  ].filter(Boolean).join('   ‚Ä¢   ') || '‚Äî';

  const metaLine1 = infoText;
  const metaLine2 = `Parziali: ${qLine}`;


  // Helpers: righe giocatori + TOT (ordinate per numero)
  const header = ['#','Atleta','PTS','FF','MIN','P/M','2PT','3PT','TL','FS','RA','RD','A','PP','PR','STf','STs','PIR','OER','+/-'];

  function rowsForXLSX(arr){
    const sorted = [...arr].sort((a,b)=> (Number(a.num||0) - Number(b.num||0)));
    const rows = sorted.map(p => ([
      p.num ?? '',
      p.name ?? '',
      p.pts||0,
      p.ff||0,
      formatTime(p.min||0),
      statsPM(p),
      `${(p['2pt']?.made||0)}/${(p['2pt']?.att||0)}`,
      `${(p['3pt']?.made||0)}/${(p['3pt']?.att||0)}`,
      `${(p.tl?.made||0)}/${(p.tl?.att||0)}`,
      p.fs||0, p.ra||0, p.rd||0, p.a||0, p.pp||0, p.pr||0, p.stf||0, p.sts||0,
      calcPIR(p),
      Number(calcOER(p)||0),
      p.pm||0,
    ]));

    const totals = teamTotals(arr);
    const pirTot = arr.reduce((sum,p)=> sum + calcPIR(p), 0);
    rows.push([
      '', 'TOT',
      totals.pts, totals.ff,
      formatTime(totals.min),
      statsPM(totals),
      `${totals['2pt'].made}/${totals['2pt'].att}`,
      `${totals['3pt'].made}/${totals['3pt'].att}`,
      `${totals.tl.made}/${totals.tl.att}`,
      totals.fs, totals.ra, totals.rd, totals.a, totals.pp, totals.pr, totals.stf, totals.sts,
      pirTot,
      Number(calcOER(totals)||0),
      totals.pm||0
    ]);
    return rows;
  }

  // Sheet "STATISTICHE"
  const aoa = [];
  aoa.push([`Statistiche partita (PIR / OER / +/-)`]);

  // META TUTTA SU UNA RIGA
  aoa.push([
    `${aName} vs ${bName}`,
    `Risultato ${scoreA}-${scoreB}`,
    `Periodo Q${periodo}`,
    `Categoria ${camp}`,
    `Girone ${gir}`,
    `Data ${date}`,
    `Giornata ${gior}`,
    `A/R ${ar}`,
    `Casa/Fuori ${cf}`,
    `Arbitri ${arb1}${arb2 ? ' / ' + arb2 : ''}`,
    `Parziali ${qLine}`
  ]);

  aoa.push([]);
  aoa.push([aName]);

  aoa.push(header);
  rowsForXLSX(playersA).forEach(r=> aoa.push(r));
  aoa.push([]);
  aoa.push([bName]);
  aoa.push(header);
  rowsForXLSX(playersB).forEach(r=> aoa.push(r));

  const ws = XLSX.utils.aoa_to_sheet(aoa);

  // Larghezze colonne (pi√π ‚Äúpulito‚Äù)
  ws['!cols'] = [
    {wch:4},   // #
    {wch:22},  // Atleta
    {wch:5}, {wch:4}, {wch:7}, {wch:6},
    {wch:7}, {wch:7}, {wch:7},
    {wch:4}, {wch:4}, {wch:4}, {wch:4},
    {wch:4}, {wch:4}, {wch:5}, {wch:5},
    {wch:5}, {wch:6}, {wch:5}
  ];

  // Freeze pane: blocca fino alla riga dell'header della prima tabella (se supportato dal viewer)
  // (alcuni Excel lo rispettano, altri no; non rompe nulla)
  ws['!freeze'] = { xSplit: 0, ySplit: 0 };

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'STATISTICHE');

  const iso = new Date().toISOString().slice(0,19).replaceAll(':','-');
  const safeA = aName.replaceAll(' ','_') || 'SquadraA';
  const safeB = bName.replaceAll(' ','_') || 'SquadraB';
  const safeD = date ? date.replaceAll('/','-').replaceAll(' ','_') : '';
  const filename = ['statistiche', safeD, `${safeA}_vs_${safeB}`, iso].filter(Boolean).join('_') + '.xlsx';

  XLSX.writeFile(wb, filename);
}

/* ===== EXPORT PDF ===== */
function exportStatsPDF(){
  const { jsPDF } = window.jspdf || {};
  if(!jsPDF){ alert('Libreria PDF non caricata (jsPDF).'); return; }
  if(!docHasAutoTable()){ alert('Plugin autoTable non caricato.'); return; }

  const aName = (nameA.value || 'Squadra A').trim();
  const bName = (nameB.value || 'Squadra B').trim();

  const scoreA = document.getElementById('scoreA')?.textContent ?? '0';
  const scoreB = document.getElementById('scoreB')?.textContent ?? '0';
  const periodo = document.getElementById('qNum')?.textContent ?? String(currentQuarter||1);

  const camp = (campionato.value || '').trim() || '‚Äî';
  const gir  = (girone.value || '').trim() || '‚Äî';
  const data = (dataGara.value || '').trim() || '‚Äî';
  const gior = (giornata.value || '').trim() || '‚Äî';
  const ar   = ((andataRitorno.value || '').trim().toUpperCase()) || '‚Äî';
  const cf   = ((casaFuori.value || '').trim().toUpperCase()) || '‚Äî';
  const arb1 = (arbitro1.value || '').trim() || '‚Äî';
  const arb2 = (arbitro2.value || '').trim() || '‚Äî';

  // Parziali Q/OT in una riga compatta
  const qLineBase = `${q1a.textContent}-${q1b.textContent} / ${q2a.textContent}-${q2b.textContent} / ${q3a.textContent}-${q3b.textContent} / ${q4a.textContent}-${q4b.textContent}`;
  const otHost = document.getElementById('otRows');
  const otParts = [];
  if(otHost){
    const rows = otHost.querySelectorAll('.qrow');
    rows.forEach((r)=>{
      const strong = r.querySelector('strong')?.textContent || '';
      const spans = r.querySelectorAll('span');
      const a = spans[0]?.textContent ?? '‚Äî';
      const b = spans[1]?.textContent ?? '‚Äî';
      if(strong) otParts.push(`${a}-${b}`);
    });
  }
  const qLine = qLineBase + (otParts.length ? (' / ' + otParts.join(' / ')) : '');

  // META (prima riga PDF)
  const infoText = [
    camp !== '‚Äî' ? `Cat: ${camp}` : null,
    gir  !== '‚Äî' ? `Gir: ${gir}` : null,
    data !== '‚Äî' ? `Data: ${data}`: null,
    gior !== '‚Äî' ? `Giornata: ${gior}` : null,
    ar   !== '‚Äî' ? `A/R: ${ar}`   : null,
    cf   !== '‚Äî' ? `C/F: ${cf}`   : null,
    arb1 !== '‚Äî' ? `Arb1: ${arb1}`: null,
    arb2 !== '‚Äî' ? `Arb2: ${arb2}`: null,
  ].filter(Boolean).join('   ‚Ä¢   ') || '‚Äî';
  const metaLine1 = infoText;
  const metaLine2 = `Parziali: ${qLine}`;


  const doc = new jsPDF({ orientation:'landscape', unit:'mm', format:'a4' });

  const pageW = doc.internal.pageSize.getWidth();
  const pageH = doc.internal.pageSize.getHeight();
  const marginX = 6;
  const marginTop = 6;
  const usableW = pageW - marginX*2;

  // Intestazione = META partita (prima riga)
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(10);
  doc.text(metaLine1, marginX, marginTop + 6);

  // Seconda riga: squadre / risultato / periodo
  doc.setFontSize(11);
  doc.text(`${aName} vs ${bName}   ‚Ä¢   Risultato: ${scoreA}-${scoreB}`, marginX, marginTop + 11);

  // Parziali (terza riga)
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(9);
  doc.text(metaLine2, marginX, marginTop + 16);


  const startY = marginTop + 20;

  const columns = ['#','Atleta','PTS','FF','MIN','P/M','2PT','3PT','TL','FS','RA','RD','A','PP','PR','STf','STs','PIR','OER','+/-'];

  function rowsForPDF(arr){
    const sorted = [...arr].sort((a,b)=> (Number(a.num||0) - Number(b.num||0)));
    return sorted.map(p => ([
      String(p.num ?? ''),
      String(p.name ?? ''),
      String(p.pts||0),
      String(p.ff||0),
      formatTime(p.min||0),
      statsPM(p),
      `${(p['2pt']?.made||0)}/${(p['2pt']?.att||0)}`,
      `${(p['3pt']?.made||0)}/${(p['3pt']?.att||0)}`,
      `${(p.tl?.made||0)}/${(p.tl?.att||0)}`,
      String(p.fs||0),
      String(p.ra||0),
      String(p.rd||0),
      String(p.a||0),
      String(p.pp||0),
      String(p.pr||0),
      String(p.stf||0),
      String(p.sts||0),
      String(calcPIR(p)),
      fmtOER(calcOER(p)),
      fmtPM(p.pm||0),
    ]));
  }

  function totalsRow(arr){
    const totals = teamTotals(arr);
    const oerTot = fmtOER(calcOER(totals));
    const pirTot = arr.reduce((sum,p)=> sum + calcPIR(p), 0);
    return [
      '', 'TOT',
      String(totals.pts),
      String(totals.ff),
      formatTime(totals.min),
      statsPM(totals),
      `${totals['2pt'].made}/${totals['2pt'].att}`,
      `${totals['3pt'].made}/${totals['3pt'].att}`,
      `${totals.tl.made}/${totals.tl.att}`,
      String(totals.fs),
      String(totals.ra),
      String(totals.rd),
      String(totals.a),
      String(totals.pp),
      String(totals.pr),
      String(totals.stf),
      String(totals.sts),
      String(pirTot),
      String(oerTot),
      fmtPM(totals.pm||0),
    ];
  }

    // === TABELLA SQUADRA A (pagina 1) ===
  // Titolo Squadra A
  doc.setFont('helvetica','bold');
  doc.setFontSize(12);
  doc.text(aName, marginX, startY + 2);

  const bodyA = [];
  rowsForPDF(playersA).forEach(r => bodyA.push(r));
  bodyA.push(totalsRow(playersA));

  doc.autoTable({
startY: startY + 6,
    margin: { left: marginX, right: marginX },
    head: [columns],
    body: bodyA,
    theme: 'grid',
    styles: { fontSize: 6.2, cellPadding: 0.85, overflow: 'linebreak', valign: 'middle' },
    alternateRowStyles: { fillColor: [230,230,230] },
    headStyles: { fillColor: [0,0,0], textColor: [255,255,255], fontSize: 6.6, cellPadding: 0.855 },
    columnStyles: { 0:{cellWidth:6}, 1:{cellWidth:38} },
    pageBreak: 'auto',
    didParseCell: (data)=>{
      const r = data.row?.raw;
      // Evidenzia riga TOT
      if(Array.isArray(r) && r[1] === 'TOT'){
        data.cell.styles.fontStyle = 'bold';
        data.cell.styles.fillColor = [210,230,255];
        data.cell.styles.textColor = [0,0,0];
      }
      // Nome atleta in grassetto (colonna Atleta)
      if(data.section === 'body' && data.column?.index === 1 && Array.isArray(r) && r[1] !== 'TOT'){
        data.cell.styles.fontStyle = 'bold';
      }
    },didDrawPage: (data)=>{
      try{
        const teamLabel = aName;
        const dateLabel = (dataGara?.value || '').trim() || '‚Äî';
        const footerLeft = `${teamLabel} ‚Ä¢ ${dateLabel}`;
        const footerRight = `Pag. ${data.pageNumber}`;
        doc.setFont('helvetica','normal');
        doc.setFontSize(8);
        doc.text(footerLeft, marginX, pageH - 5);
        doc.text(footerRight, pageW - marginX, pageH - 5, { align: 'right'
});
}catch(e){}
    }
  });

  // === NUOVA PAGINA + INTESTAZIONE (pagina 2) ===
  doc.addPage();
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(10);
  doc.text(metaLine1, marginX, marginTop + 6);
  doc.setFontSize(11);
  doc.text(`${aName} vs ${bName}   ‚Ä¢   Risultato: ${scoreA}-${scoreB}`, marginX, marginTop + 11);
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(9);
  doc.text(metaLine2, marginX, marginTop + 16);
  const startY2 = marginTop + 20;

  // === TABELLA SQUADRA B (pagina 2) ===
  // Titolo Squadra B
  doc.setFont('helvetica','bold');
  doc.setFontSize(12);
  doc.text(bName, marginX, startY2 + 2);

  const bodyB = [];
  rowsForPDF(playersB).forEach(r => bodyB.push(r));
  bodyB.push(totalsRow(playersB));

  doc.autoTable({
startY: startY2 + 6,
    margin: { left: marginX, right: marginX },
    head: [columns],
    body: bodyB,
    theme: 'grid',
    styles: { fontSize: 6.2, cellPadding: 0.85, overflow: 'linebreak', valign: 'middle' },
    alternateRowStyles: { fillColor: [230,230,230] },
    headStyles: { fillColor: [0,0,0], textColor: [255,255,255], fontSize: 6.6, cellPadding: 0.855 },
    columnStyles: { 0:{cellWidth:6}, 1:{cellWidth:38} },
    pageBreak: 'auto',
    didParseCell: (data)=>{
      const r = data.row?.raw;
      // Evidenzia riga TOT
      if(Array.isArray(r) && r[1] === 'TOT'){
        data.cell.styles.fontStyle = 'bold';
        data.cell.styles.fillColor = [210,230,255];
        data.cell.styles.textColor = [0,0,0];
      }
      // Nome atleta in grassetto (colonna Atleta)
      if(data.section === 'body' && data.column?.index === 1 && Array.isArray(r) && r[1] !== 'TOT'){
        data.cell.styles.fontStyle = 'bold';
      }
    },didDrawPage: (data)=>{
      try{
        const teamLabel = bName;
        const dateLabel = (dataGara?.value || '').trim() || '‚Äî';
        const footerLeft = `${teamLabel} ‚Ä¢ ${dateLabel}`;
        const footerRight = `Pag. ${data.pageNumber}`;
        doc.setFont('helvetica','normal');
        doc.setFontSize(8);
        doc.text(footerLeft, marginX, pageH - 5);
        doc.text(footerRight, pageW - marginX, pageH - 5, { align: 'right'
});
}catch(e){}
    }
  });

  const safeA = aName.replaceAll(' ','_') || 'SquadraA';
  const safeB = bName.replaceAll(' ','_') || 'SquadraB';
  const iso = new Date().toISOString().slice(0,19).replaceAll(':','-');
  doc.save(`statistiche_${safeA}_vs_${safeB}_${iso}.pdf`);
}

function docHasAutoTable(){
  try{
    // jsPDF autoTable plugin attaches itself as doc.autoTable
    const { jsPDF } = window.jspdf || {};
    const t = new jsPDF();
    return typeof t.autoTable === 'function';
  }catch(e){ return false; }
}


/* ===========================
   INPUT EVENTS
=========================== */
nameA.addEventListener('input', ()=>{ saveState(); render(); });
nameB.addEventListener('input', ()=>{ saveState(); render(); });

campionato.addEventListener('input', ()=> saveState());
girone.addEventListener('input', ()=> saveState());
dataGara.addEventListener('input', ()=> saveState());
giornata.addEventListener('input', ()=> saveState());
arbitro1.addEventListener('input', ()=> saveState());
arbitro2.addEventListener('input', ()=> saveState());

andataRitorno.addEventListener('input', ()=>{
  let v = (andataRitorno.value || '').toUpperCase().replaceAll(/[^AR]/g,'');
  andataRitorno.value = v.slice(0,1);
  saveState();
});
casaFuori.addEventListener('input', ()=>{
  let v = (casaFuori.value || '').toUpperCase().replaceAll(/[^CF]/g,'');
  casaFuori.value = v.slice(0,1);
  saveState();
});

/* ===========================
   IMPORT DA FILE (singola partita)
=========================== */
function applyStateObject(s){
  stopClock();
  gameClosed = false;
minusMode = false;
  document.getElementById('minusBtn')?.classList.remove('active');
  undoStack = [];
  undoInfo.textContent = '‚Äî';

  if(s?.teamA) teamA = s.teamA;
  if(s?.teamB) teamB = s.teamB;
  if(Array.isArray(s?.playersA)) playersA = s.playersA;
  if(Array.isArray(s?.playersB)) playersB = s.playersB;

  if(typeof s?.currentQuarter === 'number') currentQuarter = s.currentQuarter;
  if(typeof s?.lastScoreA === 'number') lastScoreA = s.lastScoreA;
  if(typeof s?.lastScoreB === 'number') lastScoreB = s.lastScoreB;
  if(typeof s?.sec === 'number') sec = s.sec;

  if(s?.ui){
    if(typeof s.ui.nameA === 'string') nameA.value = s.ui.nameA;
    if(typeof s.ui.nameB === 'string') nameB.value = s.ui.nameB;

    if(typeof s.ui.campionato === 'string') campionato.value = s.ui.campionato;
    if(typeof s.ui.girone === 'string') girone.value = s.ui.girone;
    if(typeof s.ui.dataGara === 'string') dataGara.value = s.ui.dataGara;
    if(typeof s.ui.giornata === 'string') giornata.value = s.ui.giornata;
    if(typeof s.ui.andataRitorno === 'string') andataRitorno.value = s.ui.andataRitorno;
    if(typeof s.ui.casaFuori === 'string') casaFuori.value = s.ui.casaFuori;
    if(typeof s.ui.arbitro1 === 'string') arbitro1.value = s.ui.arbitro1;
    if(typeof s.ui.arbitro2 === 'string') arbitro2.value = s.ui.arbitro2;
  }

  if(s?.quarters){
    for(const k of ['q1a','q1b','q2a','q2b','q3a','q3b','q4a','q4b']){
      const el = document.getElementById(k);
      
  // Nuova pagina per Squadra B
  doc.addPage();
if(el && typeof s.quarters[k] === 'string') el.textContent = s.quarters[k];
    }
    rebuildOtRowsFromState(s.quarters);
  }

  playersA = normalizePlayers(playersA, 12, 'A');
  playersB = normalizePlayers(playersB, 12, 'B');

  const fixMin = (arr)=>{
    arr.forEach(p=>{
      const v = Number(p.min);
      if (!Number.isFinite(v)) { p.min = 0; return; }
      if (!Number.isInteger(v)) p.min = Math.round(v * 60);
      else p.min = v;
    });
  };
  fixMin(playersA); fixMin(playersB);

  teamA.to = Number(teamA.to||0); teamB.to = Number(teamB.to||0);
  teamA.fts = Number(teamA.fts||0); teamB.fts = Number(teamB.fts||0);

  playersA.forEach(p=>{
    if(typeof p.pm !== 'number') p.pm = 0;
    if(typeof p.expelled !== 'boolean') p.expelled = false;
    if(typeof p.in !== 'boolean') p.in = false;
  });
  playersB.forEach(p=>{
    if(typeof p.pm !== 'number') p.pm = 0;
    if(typeof p.expelled !== 'boolean') p.expelled = false;
    if(typeof p.in !== 'boolean') p.in = false;
  });

  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }catch(e){}

  undoInfo.textContent = 'Caricato';
  render();
}

function loadGameFromFile(){
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json,.json';
  input.onchange = async () => {
    const file = input.files?.[0];
    if(!file) return;
    try{
      let text = await file.text();
      if(text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
      const payload = JSON.parse(text);

      if(payload?.__type === 'basket_stats_match' && payload.snapshots){
        CURRENT_GAME_ID = String(payload?.meta?.gameId||'').trim() || computeGameId();
        SNAPSHOT_STORE = { gameId: CURRENT_GAME_ID, baseMeta: payload.meta || {}, snaps: payload.snapshots || {} };

        const order = (k)=>{
          k = String(k||'').toUpperCase();
          if(k==='FINAL') return 9999;
          const q = k.match(/^Q(\d+)$/); if(q) return parseInt(q[1],10);
          const ot = k.match(/^OT(\d+)$/); if(ot) return 100+parseInt(ot[1],10);
          return 5000;
        };
        const keys = Object.keys(SNAPSHOT_STORE.snaps || {});
        const pick = keys.includes('FINAL') ? 'FINAL' : keys.sort((a,b)=>order(a)-order(b)).pop();
        const chosen = SNAPSHOT_STORE.snaps[pick];
        if(chosen && chosen.state){
          applyStateObject(chosen.state);
          showToast?.('Caricato file unico (match).');
        } else {
          alert('File match caricato ma snapshot vuoti/non validi.');
        }
        return;
      }

      if(payload?.__type === 'basket_stats_game' && payload.state){
        applyStateObject(payload.state);
        mergeImportedGames([{
          id: payload.meta?.id,
          name: payload.meta?.name || ('Import ' + file.name),
          date: payload.meta?.date || payload.state?.ui?.dataGara || '',
          aName: payload.meta?.aName || payload.state?.ui?.nameA || 'Squadra A',
          bName: payload.meta?.bName || payload.state?.ui?.nameB || 'Squadra B',
          opponent: payload.meta?.opponent || payload.meta?.bName || payload.state?.ui?.nameB || '',
          savedAt: payload.meta?.savedAt || new Date().toISOString(),
          state: payload.state
        }]);
        return;
      }

      if(payload?.teamA && payload?.playersA){
        applyStateObject(payload);
        mergeImportedGames([{
          id: makeGameId(),
          name: 'Import ' + file.name.replaceAll('.json',''),
          date: payload?.ui?.dataGara || '',
          aName: payload?.ui?.nameA || 'Squadra A',
          bName: payload?.ui?.nameB || 'Squadra B',
          opponent: payload?.ui?.nameB || '',
          savedAt: new Date().toISOString(),
          state: payload
        }]);
        return;
      }

      alert('File non riconosciuto.');
    }catch(e){
      console.error(e);
      alert('File non valido o corrotto.');
    }
  };
  input.click();
}

/* ===========================
   LIBRERIA PARTITE
=========================== */
const LIB_KEY = 'basket_stats_games_library_file_unico_v1';

function libLoad(){
  try{
    const raw = localStorage.getItem(LIB_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function libSave(arr){
  try{ localStorage.setItem(LIB_KEY, JSON.stringify(arr)); }catch(e){}
}
function makeGameId(){
  return 'g_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8);
}

function saveGameToLibrary(forcedName){
  const state = snapshotState();
  const meta = getMetaFromUI();
  const name = String(forcedName || meta.defaultName).trim() || meta.defaultName;

  const entry = {
    id: makeGameId(),
    name,
    date: meta.date || '',
    aName: meta.aName,
    bName: meta.bName,
    opponent: meta.opponent || '',
    savedAt: new Date().toISOString(),
    state
  };

  const lib = libLoad();
  lib.unshift(entry);
  libSave(lib);
}

function openGamesLibrary(){
  document.getElementById('gamesOverlay').style.display = 'block';
  renderLibrary();
}
function closeGamesLibrary(){
  document.getElementById('gamesOverlay').style.display = 'none';
}

function renderLibrary(){
  const tb = document.getElementById('gamesTbody');
  const info = document.getElementById('libInfo');
  const lib = libLoad();

  info.textContent = `Totale: ${lib.length}`;
  tb.innerHTML = '';

  if(!lib.length){
    tb.innerHTML = `<tr>
      <td colspan="4" style="text-align:center; color:#7f8c8d; padding:10px;">Nessuna partita salvata.</td>
    </tr>`;
    return;
  }

  lib.forEach(g=>{
    const nm = escHtml(g.name || '‚Äî');
    const dt = escHtml(g.date || '‚Äî');
    const opp = escHtml(g.opponent || g.bName || '‚Äî');

    tb.innerHTML += `
      <tr>
        <td class="lib-ellipsis" title="${nm}">${nm}</td>
        <td style="text-align:center;">${dt}</td>
        <td class="lib-ellipsis" title="${opp}">${opp}</td>
        <td style="text-align:center;">
          <button class="blue" onclick="openGameById('${g.id}')">Apri</button>
          <button class="gray" onclick="exportGameById('${g.id}')">Esporta</button>
          <button class="red" onclick="deleteGameById('${g.id}')">Elimina</button>
        </td>
      </tr>
    `;
  });
}

function openGameById(id){
  const lib = libLoad();
  const g = lib.find(x => x.id === id);
  if(!g?.state) return;
  applyStateObject(g.state);
  undoInfo.textContent = 'Aperto: ' + (g.name || 'Partita');
  closeGamesLibrary();
}

function deleteGameById(id){
  const lib = libLoad();
  const g = lib.find(x => x.id === id);
  const label = g?.name || 'questa partita';
  if(!confirm(`Eliminare "${label}" dalla libreria?`)) return;
  libSave(lib.filter(x => x.id !== id));
  renderLibrary();
}

function clearLibraryConfirm(){
  const lib = libLoad();
  if(!lib.length) return;
  if(!confirm('Svuotare completamente la libreria partite?')) return;
  libSave([]);
  renderLibrary();
}

function exportGameById(id){
  const lib = libLoad();
  const g = lib.find(x => x.id === id);
  if(!g) return;

  const payload = {
    __type: 'basket_stats_game',
    __version: 1,
    meta: {
      id: g.id,
      name: g.name,
      date: g.date,
      aName: g.aName,
      bName: g.bName,
      opponent: g.opponent,
      savedAt: g.savedAt
    },
    state: g.state
  };

  const json = JSON.stringify(payload, null, 2);
  const stamp = (g.savedAt || new Date().toISOString()).slice(0,19).replaceAll(':','-');
  const filename = `partita_${safeFilenameBase(g.name)}_${stamp}.json`;
  downloadBlob(filename, new Blob([json], { type:'application/json;charset=utf-8' }));
}

function exportLibraryBundle(){
  const lib = libLoad();
  const payload = {
    __type: 'basket_stats_library',
    __version: 1,
    exportedAt: new Date().toISOString(),
    games: lib.map(g => ({
      id: g.id,
      name: g.name,
      date: g.date,
      aName: g.aName,
      bName: g.bName,
      opponent: g.opponent,
      savedAt: g.savedAt,
      state: g.state
    }))
  };
  const json = JSON.stringify(payload, null, 2);
  const stamp = new Date().toISOString().slice(0,19).replaceAll(':','-');
  downloadBlob(`libreria_partite_${stamp}.json`, new Blob([json], { type:'application/json;charset=utf-8' }));
}

function importLibraryBundle(){
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json,.json';
  input.onchange = async () => {
    const file = input.files?.[0];
    if(!file) return;
    try{
      let text = await file.text();
      if(text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
      const payload = JSON.parse(text);

      if(payload?.__type === 'basket_stats_library' && Array.isArray(payload.games)){
        mergeImportedGames(payload.games);
        renderLibrary();
        alert(`Importate ${payload.games.length} partite (bundle).`);
        return;
      }

      if(payload?.__type === 'basket_stats_game' && payload.state){
        mergeImportedGames([{
          id: payload.meta?.id,
          name: payload.meta?.name,
          date: payload.meta?.date,
          aName: payload.meta?.aName,
          bName: payload.meta?.bName,
          opponent: payload.meta?.opponent,
          savedAt: payload.meta?.savedAt,
          state: payload.state
        }]);
        renderLibrary();
        alert('Importata 1 partita.');
        return;
      }

      alert('File non riconosciuto.');
    }catch(e){
      console.error(e);
      alert('Import fallito: file non valido.');
    }
  };
  input.click();
}

function importManyGames(){
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json,.json';
  input.multiple = true;

  input.onchange = async () => {
    const files = Array.from(input.files || []);
    if(!files.length) return;

    let count = 0;
    for(const file of files){
      try{
        let text = await file.text();
        if(text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
        const payload = JSON.parse(text);

        if(payload?.__type === 'basket_stats_game' && payload.state){
          mergeImportedGames([{
            id: payload.meta?.id,
            name: payload.meta?.name || ('Import ' + file.name),
            date: payload.meta?.date || payload.state?.ui?.dataGara || '',
            aName: payload.meta?.aName || payload.state?.ui?.nameA || 'Squadra A',
            bName: payload.meta?.bName || payload.state?.ui?.nameB || 'Squadra B',
            opponent: payload.meta?.opponent || payload.meta?.bName || payload.state?.ui?.nameB || '',
            savedAt: payload.meta?.savedAt || new Date().toISOString(),
            state: payload.state
          }]);
          count++;
          continue;
        }

        if(payload?.teamA && payload?.playersA){
          mergeImportedGames([{
            id: makeGameId(),
            name: 'Import ' + file.name.replaceAll('.json',''),
            date: payload?.ui?.dataGara || '',
            aName: payload?.ui?.nameA || 'Squadra A',
            bName: payload?.ui?.nameB || 'Squadra B',
            opponent: payload?.ui?.nameB || '',
            savedAt: new Date().toISOString(),
            state: payload
          }]);
          count++;
          continue;
        }
      }catch(e){
        // ignora file non validi
      }
    }

    renderLibrary();
    alert(`Importate ${count} partite.`);
  };

  input.click();
}

function mergeImportedGames(items){
  const lib = libLoad();
  const byId = new Map(lib.map(g => [g.id, g]));

  items.forEach(x=>{
    const id = (x.id && String(x.id)) || makeGameId();
    const entry = {
      id,
      name: String(x.name || 'Partita importata'),
      date: String(x.date || ''),
      aName: String(x.aName || x.state?.ui?.nameA || 'Squadra A'),
      bName: String(x.bName || x.state?.ui?.nameB || 'Squadra B'),
      opponent: String(x.opponent || x.bName || x.state?.ui?.nameB || ''),
      savedAt: String(x.savedAt || new Date().toISOString()),
      state: x.state
    };
    byId.set(id, entry);
  });

  const next = Array.from(byId.values()).sort((a,b)=> (b.savedAt||'').localeCompare(a.savedAt||''));
  libSave(next);
}

/* ===========================
   BOOT
=========================== */
loadState();
window.addEventListener('pageshow', () => { loadState(); render(); });
window.addEventListener('pagehide', () => { releaseWakeLock(); });
render();

/* === SORT PER COLONNA # (numero maglia) === */
function sortByNumber(side){
  const arr = (side === 'A') ? playersA : playersB;
  const th = document.querySelector(`#table${side} thead th.sortable-num`);
  const dir = th.getAttribute('data-dir') === 'asc' ? 1 : -1;

  const hasIn = arr.some(p => !!p.in);

  arr.sort((a,b)=>{
    // se esistono giocatori IN, portali in alto
    if(hasIn && a.in !== b.in){
      return a.in ? -1 : 1;
    }
    // poi ordina sempre per numero maglia
    return (Number(a.num||0) - Number(b.num||0)) * dir;
  });

  th.setAttribute('data-dir', dir === 1 ? 'desc' : 'asc');
  render();
}

document.addEventListener('click', (e)=>{
  const th = e.target.closest('th.sortable-num');
  if(!th) return;
  const table = th.closest('table');
  if(table?.id === 'tableA') sortByNumber('A');
  if(table?.id === 'tableB') sortByNumber('B');
});

</script>

<script>
function goHome(){
  window.location.href = 'cruscotto.html';
}
</script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script>

/* ===== CONDIVIDI PARTITA (SCREENSHOT) ===== */
function isLikelyMobile(){
  const ua = navigator.userAgent || '';
  const isTouch = (navigator.maxTouchPoints || 0) > 1;
  const smallScreen = Math.min(window.innerWidth || 9999, window.innerHeight || 9999) <= 820;
  // iOS / Android (inclusi tablet)
  const uaMobile = /Android|iPhone|iPad|iPod/i.test(ua);
  // Alcuni laptop touch non devono aprire la share sheet: richiediamo anche schermo piccolo o UA mobile.
  return uaMobile || (isTouch && smallScreen);
}

async function shareGame(){
  try{
    const panel = document.getElementById('statsPanel');
    if(!panel){
      alert('Statistiche non disponibili.');
      return;
    }

    if(typeof html2canvas === 'undefined'){
      alert('Funzione di condivisione non disponibile in questa build.');
      return;
    }

    // Screenshot del solo pannello Stats (overlay)
    const canvas = await html2canvas(panel, {
      backgroundColor: '#ffffff',
      scale: 2,
      useCORS: true
    });

    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
    if(!blob){
      alert('Impossibile creare l‚Äôimmagine.');
      return;
    }

    const aN = (nameA?.value || 'SquadraA').trim().replaceAll(' ','_');
    const bN = (nameB?.value || 'SquadraB').trim().replaceAll(' ','_');
    const d  = (dataGara?.value || '').trim().replaceAll('/','-');
    const campS = (campionato?.value || '').trim().replaceAll(' ','_');
    const fname = ['statistiche', campS, d, `${aN}_vs_${bN}`].filter(Boolean).join('_') + '.jpg';
    const file = new File([blob], fname, { type: 'image/jpeg' });

    // ‚úÖ Su mobile: usa la condivisione nativa
    if(isLikelyMobile() && navigator.share && (!navigator.canShare || navigator.canShare({ files:[file] }))){
      await navigator.share({
        files: [file],
        title: 'Statistiche partita',
        text: `${aN} vs ${bN}${d ? ' ‚Ä¢ ' + d : ''}`
      });
      return;
    }

    // üíª Su desktop: evita la share sheet di Windows ‚Üí scarica direttamente
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = fname;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    // Suggerimento UX (non bloccante)
    // alert('Immagine salvata. Ora puoi inviarla su WhatsApp/Telegram/social dal PC.');
  }catch(e){
    alert('Errore durante la condivisione.');
  }
}

async function shareResultCard(){
  try{
    if(typeof html2canvas === 'undefined'){
      alert('Funzione di condivisione non disponibile in questa build.');
      return;
    }

    const aName = (nameA?.value || 'Squadra A').trim();
    const bName = (nameB?.value || 'Squadra B').trim();
    const scoreA = document.getElementById('scoreA')?.textContent ?? '0';
    const scoreB = document.getElementById('scoreB')?.textContent ?? '0';

    const camp = (campionato?.value || '').trim();
    const gir  = (girone?.value || '').trim();
    const data = (dataGara?.value || '').trim();
    const gior = (giornata?.value || '').trim();
    const ar   = ((andataRitorno?.value || '').trim().toUpperCase());
    const cf   = ((casaFuori?.value || '').trim().toUpperCase());

    // Loghi offline (DataURL in localStorage)
    const logoAData = (localStorage.getItem('bs_logoA_dataurl') || '').trim();
    const logoBData = (localStorage.getItem('bs_logoB_dataurl') || '').trim();

    // Parziali Q/OT (stesso formato del PDF)
    const qLineBase = `${q1a.textContent}-${q1b.textContent} / ${q2a.textContent}-${q2b.textContent} / ${q3a.textContent}-${q3b.textContent} / ${q4a.textContent}-${q4b.textContent}`;
    const otHost = document.getElementById('otRows');
    const otParts = [];
    if(otHost){
      const rows = otHost.querySelectorAll('.qrow');
      rows.forEach((r)=>{
        const strong = r.querySelector('strong')?.textContent || '';
        const spans = r.querySelectorAll('span');
        const a = spans[0]?.textContent ?? '‚Äî';
        const b = spans[1]?.textContent ?? '‚Äî';
        if(strong) otParts.push(`${a}-${b}`);
      });
    }
    const qLine = qLineBase + (otParts.length ? (' / ' + otParts.join(' / ')) : '');

    // Card temporanea (fuori schermo) per screenshot pulito
    const host = document.createElement('div');
    host.style.position = 'fixed';
    host.style.left = '-9999px';
    host.style.top = '0';
    host.style.width = '1200px'; // abbastanza larga per social
    host.style.padding = '24px';
    host.style.background = '#ffffff';
    host.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    host.style.borderRadius = '18px';
    host.style.boxShadow = '0 10px 28px rgba(0,0,0,0.15)';

    // Watermark leggero + email (testo non cliccabile)
    const wmBox = document.createElement('div');
    wmBox.style.position = 'absolute';
    wmBox.style.right = '22px';
    wmBox.style.transform = 'translateX(0)';
    wmBox.style.bottom = '14px';
    wmBox.style.textAlign = 'center';
    wmBox.style.pointerEvents = 'none';

    const wm = document.createElement('div');
    wm.textContent = 'BASKET STATS';
    wm.style.fontWeight = '900';
    wm.style.fontSize = '28px';
    wm.style.letterSpacing = '2px';
    wm.style.color = 'rgba(0,0,0,0.08)';

    const wmEmail = document.createElement('div');
    wmEmail.textContent = 'sandro@systemdata.it';
    wmEmail.style.marginTop = '2px';
    wmEmail.style.textAlign = 'center';
    wmEmail.style.fontWeight = '700';
    wmEmail.style.fontSize = '12px';
    wmEmail.style.letterSpacing = '0.3px';
    wmEmail.style.color = 'rgba(0,0,0,0.18)';

    wmBox.appendChild(wm);
    wmBox.appendChild(wmEmail);

    host.style.position = 'fixed';
    host.style.overflow = 'hidden';


    // Crea un <img> logo da DataURL (offline) con fallback automatico
    function mkLogoData(dataUrl){
      const u = String(dataUrl||'').trim();
      if(!u || !u.startsWith('data:image/')) return null;
      const img = document.createElement('img');
      img.src = u;
      img.alt = 'logo';
      img.style.width = '76px';
      img.style.height = '76px';
      img.style.objectFit = 'contain';
      img.style.borderRadius = '14px';
      img.style.background = '#ffffff';
      img.style.boxShadow = '0 3px 10px rgba(0,0,0,0.12)';
      return img;
    }

    
    const title = document.createElement('div');
    title.style.display = 'flex';
    title.style.alignItems = 'center';
    title.style.justifyContent = 'center';
    title.style.gap = '18px';
    title.style.marginTop = '2px';

    const sA = Number(String(scoreA).replace(/[^0-9]/g,'') || 0);
    const sB = Number(String(scoreB).replace(/[^0-9]/g,'') || 0);

    const winColor = '#1e88e5'; // blu
    const loseColor = '#e53935'; // rosso
    const tieColor  = '#555';

    const colA = (sA === sB) ? tieColor : (sA > sB ? winColor : loseColor);
    const colB = (sA === sB) ? tieColor : (sB > sA ? winColor : loseColor);

    // Blocco squadra A: NOME + PUNTEGGIO colorato
    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.alignItems = 'center';
    left.style.gap = '10px';

    const nameLeft = document.createElement('div');
    nameLeft.textContent = aName;
    nameLeft.style.fontSize = '34px';
    nameLeft.style.fontWeight = '900';
    nameLeft.style.lineHeight = '1.1';
    nameLeft.style.whiteSpace = 'nowrap';

    const scoreLeft = document.createElement('div');
    scoreLeft.textContent = `${scoreA}`;
    scoreLeft.style.fontSize = '40px';
    scoreLeft.style.fontWeight = '900';
    scoreLeft.style.color = colA;

    const logoAImg = mkLogoData(logoAData);

    if(logoAImg) left.appendChild(logoAImg);
    left.appendChild(nameLeft);
    left.appendChild(scoreLeft);

    // Separatore visibile
    const sep = document.createElement('div');
    sep.textContent = '‚Äî';
    sep.style.fontSize = '46px';
    sep.style.fontWeight = '900';
    sep.style.color = '#111';
    sep.style.lineHeight = '1';

    // Blocco squadra B: NOME + PUNTEGGIO colorato
    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.alignItems = 'center';
    right.style.gap = '10px';

    const nameRight = document.createElement('div');
    nameRight.textContent = bName;
    nameRight.style.fontSize = '34px';
    nameRight.style.fontWeight = '900';
    nameRight.style.lineHeight = '1.1';
    nameRight.style.whiteSpace = 'nowrap';

    const scoreRight = document.createElement('div');
    scoreRight.textContent = `${scoreB}`;
    scoreRight.style.fontSize = '40px';
    scoreRight.style.fontWeight = '900';
    scoreRight.style.color = colB;

    const logoBImg = mkLogoData(logoBData);

    // Ordine richiesto: dopo il trattino ‚Üí RISULTATO B, poi NOME B, poi LOGO B
    right.appendChild(scoreRight);
    right.appendChild(nameRight);
    if(logoBImg) right.appendChild(logoBImg);

    title.appendChild(left);
    title.appendChild(sep);
    title.appendChild(right);

    const meta = document.createElement('div');
    meta.style.marginTop = '12px';
    meta.style.fontSize = '18px';
    meta.style.fontWeight = '700';
    meta.style.color = '#222';
    meta.style.display = 'flex';
    meta.style.flexWrap = 'wrap';
    meta.style.gap = '10px';
    meta.style.justifyContent = 'center';

    const chips = [];
    if(camp) chips.push(`Cat: ${camp}`);
    if(gir)  chips.push(`Gir: ${gir}`);
    if(data) chips.push(`Data: ${data}`);
    if(gior) chips.push(`Giornata: ${gior}`);
    if(ar)   chips.push(`A/R: ${ar}`);
    if(cf)   chips.push(`C/F: ${cf}`);
    if(!chips.length) chips.push('‚Äî');

    chips.forEach((s)=>{
      const chip = document.createElement('span');
      chip.textContent = s;
      chip.style.padding = '6px 10px';
      chip.style.borderRadius = '999px';
      chip.style.background = '#f1f3f5';
      chip.style.border = '1px solid #e6e9ee';
      meta.appendChild(chip);
    });

    
    // Progressivi (cumulati) da parziali
    const toNum = (v)=>{
      const s = String(v ?? '').trim();
      if(s === '‚Äî' || s === '') return null;
      const n = parseInt(s, 10);
      return Number.isFinite(n) ? n : null;
    };

    const splitRows = [];
    // Q1..Q4
    for(let q=1;q<=4;q++){
      const aRaw = String(document.getElementById(`q${q}a`)?.textContent ?? '‚Äî').trim();
      const bRaw = String(document.getElementById(`q${q}b`)?.textContent ?? '‚Äî').trim();
      const a = toNum(aRaw);
      const b = toNum(bRaw);
      const played = (a !== null) || (b !== null);
      splitRows.push({ label:`Q${q}`, a: a ?? 0, b: b ?? 0, played });
    }
    // OT dinamici
    if(otHost){
      const rows = [...otHost.querySelectorAll('.qrow')];
      rows.forEach(r=>{
        const label = (r.querySelector('strong')?.textContent || '').trim(); // OT1
        if(!label) return;
        const spans = r.querySelectorAll('span');
        const aRaw = String(spans[0]?.textContent ?? '‚Äî').trim();
        const bRaw = String(spans[1]?.textContent ?? '‚Äî').trim();
        const a = toNum(aRaw);
        const b = toNum(bRaw);
        const played = (a !== null) || (b !== null);
        if(played) splitRows.push({ label, a: a ?? 0, b: b ?? 0, played });
      });
    }

    // Costruisci progressivi: se manca un quarto intermedio, mostra '‚Äî' da l√¨ in poi
    let cumA = 0, cumB = 0;
    let broken = false;
    const progParts = [];
    splitRows.forEach(s=>{
      if(!s.played || broken){
        progParts.push('‚Äî');
        broken = true;
        return;
      }
      cumA += s.a;
      cumB += s.b;
      progParts.push(`${cumA}-${cumB}`);
    });

    const splits = document.createElement('div');
    splits.style.marginTop = '12px';
    splits.style.fontSize = '18px';
    splits.style.color = '#333';
    splits.style.fontWeight = '700';
    splits.style.textAlign = 'center';

    const p1 = document.createElement('div');
    p1.textContent = `Parziali: ${qLine}`;
    const p2 = document.createElement('div');
    p2.style.marginTop = '6px';
    p2.textContent = `Progressivi: ${progParts.join(' / ')}`;

    splits.appendChild(p1);
    splits.appendChild(p2);

    host.appendChild(title);
    host.appendChild(meta);
    host.appendChild(splits);
    host.appendChild(wmBox);

    document.body.appendChild(host);

    const canvas = await html2canvas(host, { backgroundColor:'#ffffff', scale: 2, useCORS:true });
    document.body.removeChild(host);

    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
    if(!blob){
      alert('Impossibile creare l‚Äôimmagine.');
      return;
    }

    const aN = aName.replaceAll(' ','_');
    const bN = bName.replaceAll(' ','_');
    const d  = (data || '').replaceAll('/','-');
    const campS = (camp || '').replaceAll(' ','_');
    const fname = ['risultato', campS, d, `${aN}_vs_${bN}`, `${scoreA}-${scoreB}`].filter(Boolean).join('_') + '.jpg';
    const file = new File([blob], fname, { type: 'image/jpeg' });

    // Su mobile: share; su desktop: download
    if(isLikelyMobile() && navigator.share && (!navigator.canShare || navigator.canShare({ files:[file] }))){
      await navigator.share({
        files: [file],
        title: 'Risultato partita',
        text: `${aName} vs ${bName}${data ? ' ‚Ä¢ ' + data : ''} ‚Ä¢ ${scoreA}-${scoreB}`
      });
      return;
    }

    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = fname;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

  }catch(e){
    alert('Errore durante la condivisione.');
  }
}


</script>

<!-- Modale selezione periodo Stats (senza prompt) -->
<div id="periodPickOverlay">
  <div class="box" role="dialog" aria-modal="true" aria-labelledby="periodPickTitle">
    <div class="hdr" id="periodPickTitle">Statistiche ‚Äì Seleziona periodo</div>
    <div class="body">
      <label for="periodPickSelect">Periodo disponibile:</label>
      <select id="periodPickSelect"></select>
      <div class="hint">
        Mostra le statistiche del periodo scelto (Q1..Q4 oppure OT).<br/>
        Nota: i dati sono disponibili solo per i periodi gi√† ‚Äúchiusi‚Äù e salvati automaticamente.
      </div>
    </div>
    <div class="actions">
      <button id="periodPickCancel" class="btn gray">Annulla</button>
      <button id="periodPickOk" class="btn blue">Apri</button>
    </div>
  </div>
</div>

<script>
/* =========================
   iPad / iOS Safari: FAST TAP
   Alcune combinazioni sticky + overflow + click inline possono perdere il tap su iOS.
   Questo listener converte il touchend in click per elementi interattivi.
========================= */
(function(){
  let lastTouchTime = 0;

  function isInteractive(el){
    if(!el) return false;
    return (
      el.matches('button') ||
      el.hasAttribute('onclick') ||
      el.classList.contains('io-btn') ||
      el.classList.contains('esp-btn') ||
      el.matches('th.sortable-num') ||
      el.matches('th[data-stats-key]')
    );
  }

  document.addEventListener('touchend', function(ev){
    const target = ev.target && ev.target.closest
      ? ev.target.closest('button,[onclick],.io-btn,.esp-btn,th.sortable-num,th[data-stats-key]')
      : null;

    if(!isInteractive(target)) return;

    // evita doppio evento (touchend + click) su alcuni iOS
    const now = Date.now();
    if(now - lastTouchTime < 350) return;
    lastTouchTime = now;

    // preveniamo che il browser "trasformi" il tap in scroll/zoom
    ev.preventDefault();

    try{ target.click(); }catch(_){}
  }, { passive:false });
})();
</script>

</body>
</html>
